/**
 * exportManager.js -- Orchestrates mould file export (STL ZIP download).
 *
 * Flow:
 *   1. User clicks Download -> downloadMouldZip() called
 *   2. Calls geometryBridge.exportParts() -> worker generates STL ArrayBuffers
 *   3. Creates JSZip, adds all STL files + a basic readme
 *   4. Generates ZIP blob and triggers browser download
 *
 * JSZip is loaded via CDN script tag (window.JSZip). NOT imported as ES module.
 */

import * as geometryBridge from './geometryBridge.js';

/**
 * Trigger a browser file download from a Blob.
 *
 * @param {Blob} blob - File content.
 * @param {string} filename - Download filename.
 */
function triggerDownload(blob, filename) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  setTimeout(() => URL.revokeObjectURL(url), 1000);
}

/**
 * Generate a basic readme for the ZIP download.
 *
 * @param {Object} mouldParams - Mould generation parameters.
 * @param {string[]} partNames - List of part names included.
 * @returns {string} Readme text content.
 */
function generateBasicReadme(mouldParams, partNames) {
  const date = new Date().toISOString().split('T')[0];
  const splitLabel = mouldParams.splitCount === 4 ? 'Quarters (4 pieces)' : 'Halves (2 pieces)';
  const slipWellLabel = mouldParams.slipWellType === 'none' ? 'None'
    : mouldParams.slipWellType === 'tall' ? 'Tall (50mm)' : 'Regular (25mm)';

  let text = '';
  text += 'Pottery Mould Parts\n';
  text += '===================\n';
  text += '\n';
  text += `Generated by Pottery Mould Generator\n`;
  text += `Date: ${date}\n`;
  text += '\n';
  text += 'Settings:\n';
  text += `  Shrinkage: ${(mouldParams.shrinkageRate * 100).toFixed(1)}%\n`;
  text += `  Wall thickness: ${mouldParams.wallThickness}mm\n`;
  text += `  Slip well: ${slipWellLabel}\n`;
  text += `  Plaster cavity gap: ${mouldParams.cavityGap}mm\n`;
  text += `  Split: ${splitLabel}\n`;
  text += '\n';
  text += 'Files included:\n';
  for (const name of partNames) {
    text += `  ${name}.stl\n`;
  }
  text += '\n';
  text += 'Assembly:\n';
  text += '  1. Print all STL files in PLA or PETG\n';
  text += '  2. Assemble using ridge/groove alignment features\n';
  text += '  3. Secure with rubber bands or clamps\n';
  text += '  4. Pour plaster through the pour hole in the ring\n';

  return text;
}

/**
 * Download all mould parts as a ZIP file containing binary STL files.
 *
 * @param {Array<ProfilePoint>} profilePoints - Current profile points.
 * @param {Object} mouldParams - Current mould parameters.
 * @param {'standard'|'high'} resolution - STL tessellation resolution.
 * @param {Object} [options] - Additional options.
 * @param {string} [options.projectName] - Name for the ZIP folder (default: 'pottery-mould').
 * @param {string} [options.readmeText] - Custom readme text to include.
 * @param {function(string): void} [options.onProgress] - Progress callback.
 * @returns {Promise<void>}
 */
export async function downloadMouldZip(profilePoints, mouldParams, resolution, options = {}) {
  if (typeof JSZip === 'undefined') {
    throw new Error('JSZip not loaded. Check that the CDN script tag is in index.html.');
  }

  const { projectName = 'pottery-mould', onProgress, readmeText } = options;

  onProgress?.('Generating STL files...');
  const exportData = await geometryBridge.exportParts(profilePoints, mouldParams, resolution);

  const zip = new JSZip();
  const folder = zip.folder(projectName);

  // Add STL files
  for (const [name, buffer] of Object.entries(exportData.stlBuffers)) {
    folder.file(`${name}.stl`, buffer);
  }

  // Add readme
  const readme = readmeText || generateBasicReadme(mouldParams, exportData.partNames);
  folder.file('README.txt', readme);

  onProgress?.('Creating ZIP...');
  const blob = await zip.generateAsync({ type: 'blob' });

  triggerDownload(blob, `${projectName}.zip`);
  onProgress?.('Done');
}
