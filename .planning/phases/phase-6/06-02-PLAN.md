---
phase: 06-outer-mould-ring-assembly
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - js/workers/geometryWorker.js
  - js/app.js
  - js/preview3d.js
  - index.html
autonomous: true

must_haves:
  truths:
    - "Bottom ring appears connecting inner mould base to outer mould base, visible as a flat washer-shaped part"
    - "Ring splits to match outer mould configuration (halves produce ring-front/ring-back, quarters produce ring-q1..q4)"
    - "All mating surfaces (outer mould split faces, ring split faces) have ridge/groove features"
    - "Ridge on one piece interlocks with groove on the mating piece -- ridge is raised, groove is recessed"
    - "Ring checkbox is enabled and toggles all ring pieces"
  artifacts:
    - path: "js/workers/geometryWorker.js"
      provides: "generateRing() function, addAssemblyFeatures() function, ring parts and ridged/grooved pieces in generateMouldParts pipeline"
      contains: "generateRing"
    - path: "js/preview3d.js"
      provides: "EXPLODED_OFFSETS entries for ring-front, ring-back (and quarter variants)"
      contains: "ring-front"
    - path: "js/app.js"
      provides: "Ring visibility toggle wiring, ring pieces rendered from worker result"
      contains: "ring-"
    - path: "index.html"
      provides: "Enabled ring checkbox"
  key_links:
    - from: "js/workers/geometryWorker.js generateRing()"
      to: "js/workers/geometryWorker.js splitSolid()"
      via: "Ring uses same splitSolid() helper from Plan 06-01"
      pattern: "splitSolid.*ring"
    - from: "js/workers/geometryWorker.js addAssemblyFeatures()"
      to: "js/workers/geometryWorker.js"
      via: "makeCylinder for ridges (fuse) and grooves (cut) on split faces"
      pattern: "makeCylinder.*fuse|makeCylinder.*cut"
    - from: "js/app.js"
      to: "js/preview3d.js"
      via: "updatePartMesh called for each ring piece"
      pattern: "updatePartMesh.*ring"
---

<objective>
Generate the bottom ring (washer connecting inner to outer mould), split it to match the outer mould configuration, and add ridge/groove assembly features to all mating surfaces on both outer mould and ring pieces.

Purpose: The ring completes the mould assembly's structural connection between inner and outer mould. Ridge/groove features enable precise alignment when assembling the 3D-printed parts for plaster casting. Without these, the mould pieces would not register accurately.

Output: Ring pieces visible in 3D preview, ridge/groove features on all split faces, ring visibility toggle enabled.
</objective>

<execution_context>
@/Users/victorhome_1/.claude/get-shit-done/workflows/execute-plan.md
@/Users/victorhome_1/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/phase-6/RESEARCH.md
@.planning/phases/phase-6/06-01-SUMMARY.md
@js/workers/geometryWorker.js
@js/workers/memoryTracker.js
@js/preview3d.js
@js/app.js
@index.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ring generation and ridge/groove assembly features to geometryWorker.js</name>
  <files>js/workers/geometryWorker.js</files>
  <action>
**A. Add generateRing() function (after generateOuterMould):**

The ring is a flat annular disc (washer shape) connecting the inner mould base to the outer mould base. It is created by revolving a small rectangular cross-section, then split using the same splitSolid() from Plan 06-01.

```javascript
/**
 * Generate the bottom ring: a washer-shaped disc connecting inner to outer mould.
 *
 * Ring sits below the mould, spanning from the inner mould's outer radius
 * to the outer mould's inner radius. Split to match outer mould configuration.
 *
 * The ring is positioned so its TOP surface aligns with the bottom of both
 * the inner and outer mould (at bottomZ), and extends downward by ringHeight.
 *
 * @param {Array} scaledPoints - Shrinkage-scaled profile points.
 * @param {Array} mouldProfile - Full mould profile (with slip well if present).
 * @param {Object} mouldParams - Mould generation parameters.
 * @param {Function} track - The withCleanup track function.
 * @returns {Array<{ key: string, solid: Object }>} Named split pieces.
 */
function generateRing(scaledPoints, mouldProfile, mouldParams, track) {
  const {
    wallThickness = 2.4,
    cavityGap = 25,
    splitCount = 2,
    ringHeight = 8,
  } = mouldParams;

  const maxProfileRadius = Math.max(...scaledPoints.map(p => p.x));
  const bottomZ = mouldProfile[0].y;

  // Ring spans from inner mould outer surface to outer mould inner surface.
  // Small clearance (0.5mm) on inner edge so the inner mould sits inside freely.
  const ringInnerRadius = maxProfileRadius + wallThickness + 0.5;
  const ringOuterRadius = maxProfileRadius + wallThickness + cavityGap;

  // Ring cross-section: rectangle from ringInner to ringOuter, below bottomZ
  const ringProfile = [
    { x: ringInnerRadius, y: bottomZ - ringHeight, type: 'line' },
    { x: ringInnerRadius, y: bottomZ, type: 'line' },
    { x: ringOuterRadius, y: bottomZ, type: 'line' },
    { x: ringOuterRadius, y: bottomZ - ringHeight, type: 'line' },
  ];

  const ringSolid = track(buildAndRevolve(ringProfile));

  // Split to match outer mould configuration
  return splitSolid(ringSolid, splitCount, track);
}
```

**B. Add addAssemblyFeatures() function (after generateRing):**

This function adds cylindrical ridges to one face and matching grooves to the mating face of each split pair. Ridges are fused (added), grooves are cut (subtracted). Grooves are slightly wider than ridges by the clearance value.

Convention: For halves, FRONT gets ridges, BACK gets grooves. For quarters, Q1/Q3 (positive X) get ridges, Q2/Q4 (negative X) get grooves on their Y=0 faces. Each quarter also has an X=0 face: Q1/Q2 (positive Y) get ridges, Q3/Q4 (negative Y) get grooves.

Simplification for v1: Only add ridges/grooves on the Y=0 split plane (the primary split). This keeps boolean operations manageable. The X=0 split plane features can be added in a gap closure plan if needed.

```javascript
/**
 * Add ridge/groove assembly features to split pieces.
 *
 * Ridges: 2mm radius cylinders fused onto one piece's split face.
 * Grooves: (2mm + clearance) radius cylinders cut from the mating piece.
 * Positioned at 1/3 and 2/3 of the piece height along the split face.
 *
 * For halves: ridges on front (Y>0 face at Y=0), grooves on back (Y<0 face at Y=0).
 * The cylinders run along the X axis (horizontal) on the Y=0 split face.
 *
 * @param {Array<{ key: string, solid: Object }>} pieces - Split pieces from splitSolid().
 * @param {string} partPrefix - 'outer' or 'ring' for naming.
 * @param {number} bottomZ - Bottom Z coordinate of the part.
 * @param {number} topZ - Top Z coordinate of the part.
 * @param {number} innerRadius - Inner radius of the part (for positioning ridges).
 * @param {number} outerRadius - Outer radius of the part (for positioning ridges).
 * @param {Object} mouldParams - Contains clearance, splitCount.
 * @param {Function} track - The withCleanup track function.
 * @returns {Array<{ key: string, solid: Object }>} Pieces with assembly features.
 */
function addAssemblyFeatures(pieces, partPrefix, bottomZ, topZ, innerRadius, outerRadius, mouldParams, track) {
  const {
    clearance = 0.3,
    splitCount = 2,
  } = mouldParams;

  const ridgeRadius = 2.0;  // mm
  const grooveRadius = ridgeRadius + clearance;
  const height = topZ - bottomZ;
  const midRadius = (innerRadius + outerRadius) / 2;

  // Ridge positions: at 1/3 and 2/3 height
  const ridgeZ1 = bottomZ + height / 3;
  const ridgeZ2 = bottomZ + (2 * height) / 3;
  const ridgeLength = (outerRadius - innerRadius) * 0.8; // 80% of radial width
  const ridgeStartX = midRadius - ridgeLength / 2;

  // For halves: front gets ridges on its Y=0 face, back gets grooves
  // Ridge cylinders run along X axis, centered on the Y=0 plane
  // They extend from ridgeStartX to ridgeStartX + ridgeLength along X
  // positioned at Y=0, at heights ridgeZ1 and ridgeZ2

  const result = [];

  for (const piece of pieces) {
    let solid = piece.solid;
    const isRidgePiece = (piece.key === 'front' || piece.key === 'q1' || piece.key === 'q3');
    const isGroovePiece = (piece.key === 'back' || piece.key === 'q2' || piece.key === 'q4');

    if (isRidgePiece) {
      // Add ridges at two heights on the Y=0 face
      // Cylinders along X axis: makeCylinder(radius, length, [startX, y, z], [1, 0, 0])
      const ridge1 = track(makeCylinder(ridgeRadius, ridgeLength, [ridgeStartX, 0, ridgeZ1], [1, 0, 0]));
      solid = track(solid.fuse(ridge1));
      const ridge2 = track(makeCylinder(ridgeRadius, ridgeLength, [ridgeStartX, 0, ridgeZ2], [1, 0, 0]));
      solid = track(solid.fuse(ridge2));
    }

    if (isGroovePiece) {
      // Cut grooves at matching positions (slightly larger radius for clearance)
      const groove1 = track(makeCylinder(grooveRadius, ridgeLength + 2, [ridgeStartX - 1, 0, ridgeZ1], [1, 0, 0]));
      solid = track(solid.cut(groove1));
      const groove2 = track(makeCylinder(grooveRadius, ridgeLength + 2, [ridgeStartX - 1, 0, ridgeZ2], [1, 0, 0]));
      solid = track(solid.cut(groove2));
    }

    result.push({ key: piece.key, solid });
  }

  return result;
}
```

**C. Integrate ring and assembly features into generateMouldParts():**

In `generateMouldParts()`, after the outer mould section, add ring generation and assembly features. Also wrap the outer mould assembly features:

```javascript
    // Ring: washer connecting inner to outer mould base
    try {
      const ringPieces = generateRing(scaledPoints, mouldProfile, mouldParams, track);

      // Add assembly features to ring pieces
      const ringBottomZ = mouldProfile[0].y - (mouldParams.ringHeight || 8);
      const ringTopZ = mouldProfile[0].y;
      const ringInnerR = Math.max(...scaledPoints.map(p => p.x)) + wallThickness + 0.5;
      const ringOuterR = Math.max(...scaledPoints.map(p => p.x)) + wallThickness + cavityGap;
      const ridgedRingPieces = addAssemblyFeatures(
        ringPieces, 'ring', ringBottomZ, ringTopZ, ringInnerR, ringOuterR, mouldParams, track
      );

      for (const piece of ridgedRingPieces) {
        results[`ring-${piece.key}`] = toTransferableMesh(piece.solid.mesh(meshOpts));
      }
    } catch (ringErr) {
      console.warn('[worker] Ring generation failed:', ringErr.message);
      results['ring-error'] = {
        message: `Ring generation failed: ${ringErr.message}`,
      };
    }
```

ALSO: Wrap the existing outer mould pieces with assembly features. Modify the outer mould section (from Plan 06-01) to add ridges/grooves AFTER splitting:

```javascript
    // Outer mould: cylindrical shell split into halves or quarters
    try {
      const outerPieces = generateOuterMould(scaledPoints, mouldProfile, mouldParams, track);

      // Add assembly features (ridges/grooves) to outer mould split faces
      const outerBottomZ = mouldProfile[0].y;
      const outerTopZ = mouldProfile[mouldProfile.length - 1].y;
      const maxProfileRadius = Math.max(...scaledPoints.map(p => p.x));
      const outerInnerR = maxProfileRadius + wallThickness + cavityGap;
      const outerOuterR = outerInnerR + (mouldParams.outerWallThickness || 2.4);
      const ridgedOuterPieces = addAssemblyFeatures(
        outerPieces, 'outer', outerBottomZ, outerTopZ, outerInnerR, outerOuterR, mouldParams, track
      );

      for (const piece of ridgedOuterPieces) {
        results[`outer-${piece.key}`] = toTransferableMesh(piece.solid.mesh(meshOpts));
      }
    } catch (outerErr) {
      console.warn('[worker] Outer mould generation failed:', outerErr.message);
      results['outer-mould-error'] = {
        message: `Outer mould failed: ${outerErr.message}`,
      };
    }
```

NOTE: This modifies the outer mould section written in Plan 06-01. The change is: instead of meshing `outerPieces` directly, pass them through `addAssemblyFeatures()` first, then mesh the ridged pieces.

**D. Add ringHeight to mouldParams destructuring:**

Update the destructuring at the top of `generateMouldParts()`:

```javascript
  const {
    shrinkageRate = 0.13,
    wallThickness = 2.4,
    slipWellType = 'regular',
    cavityGap = 25,
    splitCount = 2,
    outerWallThickness = 2.4,
    clearance = 0.3,
    ringHeight = 8,
  } = mouldParams || {};
```

**E. Performance consideration:**

Assembly features add 4 boolean operations per part type (2 ridges + 2 grooves per split pair). For halves: 4 ops for outer + 4 for ring = 8 extra. For quarters: 8 + 8 = 16 extra. At 100-300ms each, this adds 0.8-4.8s.

If total generation time is unacceptable (>5s), the executor should add a performance flag to skip assembly features during live preview. But implement WITH features first and measure. The RESEARCH.md recommendation to skip features during preview can be done as a gap closure optimization if needed.
  </action>
  <verify>
1. Check generateRing function: `grep "function generateRing" js/workers/geometryWorker.js`
2. Check addAssemblyFeatures function: `grep "function addAssemblyFeatures" js/workers/geometryWorker.js`
3. Check ring integrated into pipeline: `grep "ring-.*piece.key" js/workers/geometryWorker.js`
4. Check makeCylinder used for ridges: `grep "makeCylinder.*ridgeRadius" js/workers/geometryWorker.js`
5. Check ridge fuse operation: `grep "solid.fuse.*ridge" js/workers/geometryWorker.js`
6. Check groove cut operation: `grep "solid.cut.*groove" js/workers/geometryWorker.js`
7. Check clearance in params: `grep "clearance" js/workers/geometryWorker.js`
8. Check outer mould also gets assembly features: `grep "addAssemblyFeatures.*outer" js/workers/geometryWorker.js`
9. Check ring error handling: `grep "ring-error" js/workers/geometryWorker.js`
  </verify>
  <done>
Worker generates ring as washer-shaped disc connecting inner to outer mould, split to match outer mould config. Ridge/groove assembly features added to all split faces of both outer mould and ring. Ridges are 2mm radius cylinders fused to one face, grooves are 2.3mm radius (2mm + 0.3mm clearance) cut from the mating face, positioned at 1/3 and 2/3 height.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire ring into preview and enable ring visibility toggle</name>
  <files>js/app.js, index.html</files>
  <action>
**A. Enable the Ring checkbox in index.html:**

Change the ring checkbox from disabled to enabled:

```html
<!-- Before: -->
<input type="checkbox" id="chk-show-ring" checked disabled> Ring

<!-- After: -->
<input type="checkbox" id="chk-show-ring" checked> Ring
```

**B. Wire ring visibility toggle in app.js initViewControls():**

After the outer mould checkbox wiring (added in Plan 06-01), add:

```javascript
  const chkRing = document.getElementById('chk-show-ring');
  if (chkRing) {
    chkRing.addEventListener('change', () => {
      preview3d.setPartGroupVisibility('ring-', chkRing.checked);
    });
  }
```

**C. Update onProfileChange() in app.js to handle ring parts:**

After the outer mould piece handling (from Plan 06-01), add ring piece handling using the same pattern:

```javascript
    // Clear and update ring pieces
    preview3d.removePartsByPrefix('ring-');
    for (const [partName, meshData] of Object.entries(mouldResult)) {
      if (partName.startsWith('ring-') && !partName.endsWith('-error') && meshData.vertices) {
        preview3d.updatePartMesh(partName, meshData);
      }
    }
```

**D. Apply the same ring handling in regenerateMould():**

Mirror the changes from onProfileChange into regenerateMould(). The same `removePartsByPrefix('ring-')` + loop pattern.

```javascript
    // Clear and update ring pieces
    preview3d.removePartsByPrefix('ring-');
    for (const [partName, meshData] of Object.entries(mouldResult)) {
      if (partName.startsWith('ring-') && !partName.endsWith('-error') && meshData.vertices) {
        preview3d.updatePartMesh(partName, meshData);
      }
    }
```

**E. Handle ring-error in app.js:**

In both `onProfileChange()` and `regenerateMould()`, add:

```javascript
    if (mouldResult['ring-error']) {
      console.warn('[app] Ring error:', mouldResult['ring-error'].message);
    }
```

**F. Also update the initial WASM upgrade section in the DOMContentLoaded handler:**

After the existing inner-mould handling in the initial load section, add:

```javascript
        // Update outer mould and ring pieces from initial generation
        for (const [partName, meshData] of Object.entries(mouldResult)) {
          if ((partName.startsWith('outer-') || partName.startsWith('ring-')) && meshData.vertices) {
            preview3d.updatePartMesh(partName, meshData);
          }
        }
```
  </action>
  <verify>
1. Check ring checkbox enabled: `grep "chk-show-ring" index.html` should NOT show "disabled"
2. Check ring visibility wiring: `grep "chk-show-ring.*setPartGroupVisibility\|setPartGroupVisibility.*ring" js/app.js`
3. Check ring parts handled in onProfileChange: `grep "removePartsByPrefix.*ring\|startsWith.*ring" js/app.js`
4. Check ring-error handling: `grep "ring-error" js/app.js`
5. Open app in browser: ring appears as flat washer below the mould assembly. Ring checkbox toggles it. Exploded view moves ring below other parts. Ridge/groove features visible on split faces when zoomed in.
  </verify>
  <done>
Ring pieces render in 3D preview, split to match outer mould config. Ring checkbox enabled and toggles all ring pieces. Ridge/groove features visible on split faces of both outer mould and ring. Initial page load generates all mould parts. Error states handled gracefully.
  </done>
</task>

</tasks>

<verification>
1. Ring appears as flat washer connecting inner mould base to outer mould base
2. Ring splits match outer mould split count (halves -> ring-front/ring-back, quarters -> ring-q1..q4)
3. Ridge cylinders visible on one face of each split pair (raised bumps on the Y=0 face)
4. Groove channels visible on the mating face (recessed channels matching ridge positions)
5. Grooves are wider than ridges by clearance amount (default 0.3mm per side)
6. Assembly features applied to BOTH outer mould AND ring split faces
7. Ring checkbox toggles all ring pieces independently
8. All WASM objects tracked via withCleanup
9. Ring/assembly errors do not prevent other parts from generating
10. splitSolid() helper reused from Plan 06-01 (no code duplication)
</verification>

<success_criteria>
- Ring appears as a flat washer below the inner and outer mould
- Ring splits match outer mould configuration (halves or quarters)
- Ridge/groove features visible on zoomed-in view of split faces
- Ridge pieces have raised cylindrical bumps; mating pieces have recessed channels
- Ring checkbox toggles ring visibility independently
- Changing split count regenerates both outer mould and ring with correct piece count
</success_criteria>

<output>
After completion, create `.planning/phases/phase-6/06-02-SUMMARY.md`
</output>
