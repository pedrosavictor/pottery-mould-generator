---
phase: 02-profile-editor-core
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - js/profileEditor/constraints.js
  - js/profileEditor.js
  - js/profileEditor/editTool.js
  - css/style.css
autonomous: true

must_haves:
  truths:
    - "Dragging a point past the revolution axis (x < 0) is visually blocked -- the point stops at x = 0"
    - "Creating an undercut (radius decreasing while moving upward above the foot zone) shows a red visual warning on the offending curve section"
    - "Self-intersecting curves are detected and highlighted with red markers at intersection points"
    - "Constraint violations are checked in real-time during drag operations"
    - "User can still edit freely in the foot zone (first ~5mm of height) without undercut warnings"
  artifacts:
    - path: "js/profileEditor/constraints.js"
      provides: "Undercut detection, self-intersection detection, axis crossing detection, visual violation rendering"
      exports: ["validateConstraints", "enforceAxisBound", "renderViolations", "clearViolations"]
  key_links:
    - from: "js/profileEditor/constraints.js"
      to: "js/profileEditor/canvasSetup.js"
      via: "uses transform.toProfile for converting canvas coords to mm for constraint checks"
      pattern: "transform\\.toProfile"
    - from: "js/profileEditor/editTool.js"
      to: "js/profileEditor/constraints.js"
      via: "calls enforceAxisBound during drag, validateConstraints on mouseUp"
      pattern: "enforceAxisBound|validateConstraints"
    - from: "js/profileEditor/constraints.js"
      to: "Paper.js path"
      via: "reads path.curves and path.segments for geometric analysis"
      pattern: "path\\.curves|path\\.segments"
---

<objective>
Add real-time constraint enforcement to the profile editor: prevent axis crossings (x < 0), detect and flag undercuts (radius decreasing above foot zone), and detect self-intersections. Visual feedback shows constraint violations as the user edits.

Purpose: Invalid geometry causes revolve failures and unprintable moulds. Catching errors during editing (not after) is essential for a smooth user experience. This satisfies PROF-09.

Output: A constraints module that validates profile geometry in real-time and renders visual violation markers.
</objective>

<execution_context>
@/Users/victorhome_1/.claude/get-shit-done/workflows/execute-plan.md
@/Users/victorhome_1/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/phase-2/RESEARCH.md
@.planning/phases/phase-2/02-01-SUMMARY.md
@js/profileData.js
@js/profileEditor.js
@js/profileEditor/canvasSetup.js
@js/profileEditor/pathRenderer.js
@js/profileEditor/editTool.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Constraint validation engine (undercut, self-intersection, axis crossing)</name>
  <files>
    js/profileEditor/constraints.js
  </files>
  <action>
Create `js/profileEditor/constraints.js` with four exported functions. All constraint checks operate on PROFILE coordinates (mm), not canvas coordinates, to avoid coordinate-system confusion.

**Export `enforceAxisBound(segment, transform)`:**
- Called DURING drag (every frame) as a hard constraint
- Convert `segment.point` to profile coords via `transform.toProfile(segment.point)`
- If profile `x < 0`, clamp: set `segment.point` to `transform.toCanvas(0, profileY)` where profileY is the original y
- This prevents the point from crossing the revolution axis entirely
- Also clamp bezier handles: if a handle tip position would put the control point at profile x < 0, clamp the handle length to stop at x = 0
- Return `{ clamped: boolean }` to indicate if clamping occurred

**Export `validateConstraints(path, transform, options)`:**
- Called AFTER drag completes (on mouseUp) as a soft constraint check
- `options.footZoneHeight` (default 5) -- mm height below which undercut rule is relaxed
- Returns `{ valid: boolean, violations: Array<Violation> }` where each Violation has `{ type, message, points, curveIndices }`

**Violation types:**

1. **Axis Crossing (`type: 'axisCrossing'`):**
   - Check each segment anchor point: `transform.toProfile(segment.point).x < 0`
   - Check each curve's bounding box left edge: if `transform.toProfile(new paper.Point(curve.bounds.left, 0)).x < -0.1` (small tolerance for floating point)
   - Return violation with affected segment indices and the x-value

2. **Undercut (`type: 'undercut'`):**
   - Convert all segment points to profile coordinates
   - For each pair of adjacent points where both are above `footZoneHeight` (both `y > footZoneHeight`):
     - If the later point (higher y) has a SMALLER x (radius) than the earlier point (lower y), flag undercut
   - For bezier curves above the foot zone: sample the curve at 20 evenly-spaced points along its length. Check that the profile-coordinate x is monotonically non-decreasing as y increases. The sampling uses `curve.getPointAtTime(t)` for `t` from 0 to 1 in increments of 0.05.
   - IMPORTANT: The monotonicity check direction depends on whether the curve goes upward. Since the profile goes foot-to-rim (y-increasing), and we traverse segments in order, check that profile x does not decrease significantly along the curve. Use a tolerance of `-0.5mm` (small dips from floating point are OK).
   - Return violation with the curve index and the sample points where the undercut occurs

3. **Self-Intersection (`type: 'selfIntersection'`):**
   - Paper.js has NO single-path self-intersection method (per research Pitfall 3)
   - Split the path into individual curves and test NON-ADJACENT pairs
   - For each pair of curves `(i, j)` where `j >= i + 2` (skip adjacent curves which share endpoints):
     - Create temporary 2-segment paths: `new paper.Path({ segments: [curve.segment1.clone(), curve.segment2.clone()], insert: false })`
     - Call `pathA.getIntersections(pathB)`
     - Collect all intersection points
     - Remove temporary paths
   - Return violation with intersection points (in canvas coords for rendering)

**Export `clearViolations(overlayLayer)`:**
- Remove all children from the overlay layer
- Called before rendering new violations

**Export `renderViolations(violations, overlayLayer, transform)`:**
- Activate `overlayLayer`
- For each violation:

  - **axisCrossing:** Draw a semi-transparent red vertical band from x=0 extending 5px left, full canvas height. Draw a red dashed line at x=0 axis position.

  - **undercut:** For each offending curve, draw a red semi-transparent overlay tracing the curve section. Use `new paper.Path()` with red fill (`new paper.Color(1, 0, 0, 0.15)`) and red stroke (`new paper.Color(1, 0, 0, 0.7)`, strokeWidth 3). Also place a small warning icon (red circle with "!" text or just a red dot) at the midpoint of the offending section.

  - **selfIntersection:** Draw a red X marker at each intersection point: two crossed lines (8px) with red stroke (strokeWidth 2). Also draw a red circle (radius 6px, fill `rgba(255,0,0,0.3)`, stroke red).

- Call `paper.view.requestUpdate()` after rendering

**Internal helper `sampleCurveProfile(curve, transform, numSamples)`:**
- Returns array of `{ t, x, y }` where x and y are profile coordinates (mm)
- Uses `curve.getPointAtTime(t)` and `transform.toProfile()` for each sample
- Used by undercut detection

**Internal helper `findUndercutSamples(samples, footZoneHeight)`:**
- Given sorted samples (by increasing y), find consecutive pairs where x decreases above the foot zone
- Returns array of `{ fromSample, toSample }` pairs identifying undercut regions
  </action>
  <verify>
Create a test scenario: manually set profile points that create each violation type and verify detection:
1. Set a point with negative x -> `validateConstraints` returns axisCrossing violation
2. Set points where radius decreases going upward above foot zone -> returns undercut violation
3. Create a profile where two non-adjacent curves cross -> returns selfIntersection violation
4. Verify foot zone (y < 5mm) is exempt from undercut detection
5. Verify `enforceAxisBound` clamps a point at x < 0 back to x = 0

Run in browser console:
```javascript
// After editor is initialized, get the path and transform from the editor
// Test undercut: move a mid-profile point inward
// Verify red warnings appear on the canvas
```
  </verify>
  <done>
The constraint validation engine correctly detects axis crossings, undercuts (above foot zone only), and self-intersections. Each violation type produces the correct structured output for rendering.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire constraints into edit tool and editor with real-time feedback</name>
  <files>
    js/profileEditor/editTool.js
    js/profileEditor.js
    css/style.css
  </files>
  <action>
**1. Update `js/profileEditor/editTool.js`:**

Import constraints: `import { enforceAxisBound, validateConstraints, renderViolations, clearViolations } from './constraints.js';`

Modify `onMouseDrag(event)`:
- AFTER moving the segment point or handle, call `enforceAxisBound(selectedSegment, editorState.getTransform())` to hard-clamp axis crossings during drag
- This gives immediate tactile feedback: the point "sticks" at x=0 and won't go further left
- Also run a LIGHTWEIGHT constraint check during drag for visual feedback:
  - Call `validateConstraints(editorState.getPath(), editorState.getTransform())` on every ~3rd drag event (throttle with a frame counter to avoid checking every pixel of movement)
  - Call `clearViolations(editorState.getLayers().overlay)` then `renderViolations(violations, editorState.getLayers().overlay, editorState.getTransform())`
  - This shows red warnings appearing/disappearing as the user drags

Modify `onMouseUp(event)`:
- Run FULL constraint validation: `const { valid, violations } = validateConstraints(path, transform)`
- Render violations: `clearViolations(layers.overlay); renderViolations(violations, layers.overlay, transform);`
- Pass `valid` status to `notifyChange()` so the editor can decide whether to update 3D preview
- If valid: trigger 3D preview update via `notifyChange()`
- If invalid: still call `notifyChange()` but include the violations. The 3D preview can still update (the geometry worker will either succeed or fail gracefully) -- we show warnings but do NOT block edits. The user needs to be able to drag through invalid states to reach valid ones.

**2. Update `js/profileEditor.js`:**

Update the `notifyChange()` function to include constraint status:
```javascript
function notifyChange() {
  const points = syncPathToProfile(currentPath, currentTransform);
  const profile = createProfile(points);
  const { valid, violations } = validateConstraints(currentPath, currentTransform);

  // Render violation markers
  clearViolations(layers.overlay);
  if (violations.length > 0) {
    renderViolations(violations, layers.overlay, currentTransform);
  }

  // Always notify (let 3D preview attempt update even with warnings)
  if (options.onChange) {
    options.onChange(profile, { valid, violationCount: violations.length });
  }
}
```

Update `setProfileData(profile)` to also run constraint validation after rendering the new profile (needed for undo/redo in plan 02-03).

Add import for constraints module at the top of profileEditor.js.

**3. Update `css/style.css`:**

Add a constraint status indicator area. Add to the editor container:
```css
#constraint-status {
  position: absolute;
  bottom: 8px;
  left: 8px;
  z-index: 10;
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 0.75rem;
  font-weight: 500;
}

#constraint-status.valid {
  background: rgba(122, 139, 111, 0.9);
  color: white;
}

#constraint-status.invalid {
  background: rgba(200, 50, 50, 0.9);
  color: white;
}
```

Add a `<div id="constraint-status" class="valid">Profile OK</div>` inside `#editor-container` in index.html.

Update `notifyChange()` to update this status element:
```javascript
const statusEl = document.getElementById('constraint-status');
if (statusEl) {
  if (violations.length === 0) {
    statusEl.textContent = 'Profile OK';
    statusEl.className = 'valid';
  } else {
    const messages = violations.map(v => v.type === 'undercut' ? 'Undercut' : v.type === 'selfIntersection' ? 'Self-intersection' : 'Axis crossing');
    statusEl.textContent = [...new Set(messages)].join(', ');
    statusEl.className = 'invalid';
  }
}
```
  </action>
  <verify>
Open browser and test each constraint scenario:

1. **Axis clamping:** In edit mode, drag a point toward the left edge (revolution axis). Verify the point stops at x=0 and cannot go further left. The handle should also be clamped.

2. **Undercut warning:** Drag the belly point (widest part of the cup) inward so the radius above the foot is smaller than below. Verify a red overlay appears on the curve section with the undercut. The status indicator at bottom-left should show "Undercut".

3. **Self-intersection:** Drag a point so its bezier curve crosses another curve. Verify red X markers appear at intersection points. Status shows "Self-intersection".

4. **Foot zone exemption:** The test profile has a tuck at point 2 (x goes from 30 to 25 at y=5). This is IN the foot zone (y < 5mm) and should NOT trigger an undercut warning.

5. **Valid state:** After fixing all violations (dragging points back to valid positions), verify all red markers disappear and status returns to "Profile OK".

6. **3D preview still updates:** Even with violations showing, the 3D preview should still attempt to update on mouseUp (it may fail gracefully if geometry is invalid, but it should not be blocked).
  </verify>
  <done>
Constraint enforcement operates in real-time during editing. Axis crossings are hard-blocked (clamped during drag). Undercuts and self-intersections are soft-warned with red visual overlays and a status indicator. The foot zone is exempt from undercut checks. Users are not blocked from editing -- they see warnings and can fix them. Requirement PROF-09 is satisfied.
  </done>
</task>

</tasks>

<verification>
1. `enforceAxisBound` prevents any point from having profile x < 0
2. Undercut detection correctly identifies radius-decreasing sections above the foot zone
3. Undercut detection correctly EXEMPTS the foot zone (y < footZoneHeight)
4. Self-intersection detection finds crossings between non-adjacent curve pairs
5. Self-intersection detection does NOT flag adjacent curves sharing endpoints
6. Visual violation markers render correctly (red overlays, X markers)
7. Violation markers are cleared when the profile returns to a valid state
8. Status indicator updates in real-time
9. Constraint checks do not noticeably lag during drag operations
10. The 3D preview is not blocked by constraint violations
</verification>

<success_criteria>
- Axis crossing is hard-blocked: points cannot go past x = 0
- Undercuts above foot zone trigger visible red warnings
- Self-intersections trigger visible red X markers
- Foot zone (first ~5mm height) is exempt from undercut checks
- Status indicator shows "Profile OK" or violation type names
- Editing is not blocked by soft constraints -- user can drag through invalid states
- Requirement PROF-09 (constraint enforcement) is functionally complete
</success_criteria>

<output>
After completion, create `.planning/phases/phase-2/02-02-SUMMARY.md`
</output>
