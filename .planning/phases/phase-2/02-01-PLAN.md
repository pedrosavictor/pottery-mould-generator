---
phase: 02-profile-editor-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - index.html
  - js/profileEditor.js
  - js/profileEditor/canvasSetup.js
  - js/profileEditor/pathRenderer.js
  - js/profileEditor/editTool.js
  - js/profileEditor/drawTool.js
  - js/app.js
  - css/style.css
autonomous: true

must_haves:
  truths:
    - "User sees a 2D canvas with a rendered pot profile (the test cup from Phase 1) drawn as bezier curves"
    - "User can click and drag anchor points to reshape the profile"
    - "User can click and drag bezier control handles to adjust curve shape"
    - "User can click on a curve segment to insert a new point"
    - "User can select a point and delete it with Backspace/Delete key"
    - "Editing the profile in the 2D editor triggers a 3D preview update (debounced via generateWithCancellation)"
  artifacts:
    - path: "js/profileEditor.js"
      provides: "Main editor module: init, tool switching, profile change dispatch"
      exports: ["initProfileEditor", "getProfileData", "setProfileData"]
    - path: "js/profileEditor/canvasSetup.js"
      provides: "Paper.js initialization, coordinate transforms (mm <-> canvas)"
      exports: ["initCanvas", "createTransform"]
    - path: "js/profileEditor/pathRenderer.js"
      provides: "Renders profile data model as Paper.js path with custom handle decorators"
      exports: ["renderProfile", "renderHandles"]
    - path: "js/profileEditor/editTool.js"
      provides: "Paper.js Tool for selecting/dragging points and handles"
      exports: ["createEditTool"]
    - path: "js/profileEditor/drawTool.js"
      provides: "Paper.js Tool for adding new points and deleting points"
      exports: ["createDrawTool"]
  key_links:
    - from: "js/profileEditor.js"
      to: "js/profileData.js"
      via: "imports createProfile, syncs Paper.js edits back to data model"
      pattern: "import.*profileData"
    - from: "js/profileEditor/pathRenderer.js"
      to: "js/profileEditor/canvasSetup.js"
      via: "uses createTransform for mm-to-canvas coordinate conversion"
      pattern: "transform\\.toCanvas"
    - from: "js/app.js"
      to: "js/profileEditor.js"
      via: "initProfileEditor call, onChange callback triggers generateWithCancellation"
      pattern: "initProfileEditor.*onChange"
    - from: "js/profileEditor/editTool.js"
      to: "js/profileEditor/pathRenderer.js"
      via: "calls renderHandles after drag operations to update handle decorators"
      pattern: "renderHandles"
---

<objective>
Set up the Paper.js 2D profile editor canvas with bezier curve rendering, interactive point/handle dragging, point insertion on curves, and point deletion. Wire the editor into the existing app so profile changes flow to the 3D preview.

Purpose: This is the foundation of the profile editor -- the primary user interaction surface. All subsequent Phase 2 plans (constraints, undo, grid, dimensions) build on this canvas infrastructure.

Output: A working 2D bezier editor where the user can see, draw, and manipulate the pot profile, with changes reflected in the 3D preview.
</objective>

<execution_context>
@/Users/victorhome_1/.claude/get-shit-done/workflows/execute-plan.md
@/Users/victorhome_1/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/STATE.md
@.planning/phases/phase-2/RESEARCH.md
@.planning/phases/phase-1/01-02-SUMMARY.md
@.planning/phases/phase-1/01-03-SUMMARY.md
@js/profileData.js
@js/geometryBridge.js
@js/app.js
@index.html
@css/style.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Paper.js canvas setup, coordinate transforms, and path rendering</name>
  <files>
    index.html
    js/profileEditor/canvasSetup.js
    js/profileEditor/pathRenderer.js
    js/profileEditor.js
    css/style.css
  </files>
  <action>
**1. Update index.html:**

Add Paper.js CDN script tag BEFORE the module script (classic scripts execute before modules):
```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.12.18/paper-core.min.js"></script>
```

Replace the `<main>` content to add a profile editor panel. The layout becomes a 3-panel split:
- Left: profile editor canvas (the new 2D editor)
- Right: 3D preview (existing `#preview-container`)
- Far right: controls sidebar (existing `aside#controls`)

Add inside `<main>`, BEFORE `#preview-container`:
```html
<div id="editor-container">
  <div id="editor-toolbar">
    <button id="btn-edit-tool" class="tool-btn active" title="Edit points and handles">Edit</button>
    <button id="btn-draw-tool" class="tool-btn" title="Add points to profile">Draw</button>
  </div>
  <canvas id="profile-canvas" resize></canvas>
</div>
```

Keep the existing `#preview-container` and `aside#controls` sections. Update the aside heading from "Phase 1 Test Harness" to "Controls". Keep the Phase 1 test buttons functional for now (they still work for debugging).

**2. Create `js/profileEditor/canvasSetup.js`:**

This module initializes Paper.js and provides coordinate transforms. Paper.js is accessed via the global `paper` object (loaded by CDN script tag). Do NOT use `paper.install(window)`.

Export `initCanvas(canvasId)`:
- Call `paper.setup(canvasId)` to create Project + View
- Leave `autoUpdate` at default `true` (simpler; performance is fine for <100 items per research)
- Create 4 layers in order: `grid` (background), `profile` (the path), `handles` (anchor/control point decorators), `overlay` (constraints, measurements -- used by later plans)
- Activate the `profile` layer
- Return `{ project: paper.project, view: paper.view, layers: { grid, profile, handles, overlay } }`

Export `createTransform(canvasWidth, canvasHeight, options)`:
- `options` has optional `maxRadiusMm` (default 60) and `maxHeightMm` (default 120) to define the profile space bounds
- Calculate `scale` (pixels per mm) = `Math.min(canvasWidth * 0.7 / maxRadiusMm, canvasHeight * 0.8 / maxHeightMm)`
- Calculate `offsetX` = `canvasWidth * 0.15` (left margin for axis labels in future)
- Calculate `offsetY` = `canvasHeight * 0.9` (bottom margin, y-flipped)
- Return object with:
  - `scale` (number, pixels per mm)
  - `toCanvas(profileX, profileY)` -> `new paper.Point(offsetX + profileX * scale, offsetY - profileY * scale)` -- NOTE the Y-flip
  - `toProfile(canvasPoint)` -> `{ x: (canvasPoint.x - offsetX) / scale, y: (offsetY - canvasPoint.y) / scale }` -- NOTE the Y-flip
  - `mmToPixels(mm)` -> `mm * scale`
  - `pixelsToMm(px)` -> `px / scale`
  - `offsetX`, `offsetY` (for grid rendering access)

**CRITICAL COORDINATE DETAIL:** Paper.js canvas Y increases downward. Profile data Y increases upward. The transform must negate Y in both directions.

**3. Create `js/profileEditor/pathRenderer.js`:**

This module renders the profile data model as a Paper.js Path with custom handle decorators.

Export `renderProfile(profilePoints, transform, profileLayer)`:
- Activate `profileLayer`
- Remove all existing children from `profileLayer`
- Build an array of `paper.Segment` objects from profile points:
  - For each point `i`, create the segment anchor at `transform.toCanvas(pt.x, pt.y)`
  - Handle mapping (CRITICAL -- this is the #1 source of bugs per research):
    - `handleIn` for segment `i`: If `profilePoints[i].type === 'bezier'` and has `cp2`, compute `transform.toCanvas(cp2.x, cp2.y).subtract(anchorCanvasPoint)` (RELATIVE offset)
    - `handleOut` for segment `i`: If `profilePoints[i+1]` exists AND `profilePoints[i+1].type === 'bezier'` AND has `cp1`, compute `transform.toCanvas(cp1.x, cp1.y).subtract(anchorCanvasPoint)` (RELATIVE offset)
    - For `line` type segments, both handles are `null` (zero-length)
- Create `new paper.Path({ segments, strokeColor: '#2d2d2d', strokeWidth: 2.5, selected: false })`
- Return the path

Export `renderHandles(path, handleLayer)`:
- Activate `handleLayer`
- Remove all existing children from `handleLayer`
- For each segment in `path.segments`:
  - Draw a filled circle (radius 5px, fill `#2d2d2d`, stroke `white` 1.5px) at `segment.point` for the anchor
  - If `segment.handleIn` is not zero: draw a line from `segment.point` to `segment.point.add(segment.handleIn)` (strokeColor `#c2956b`, strokeWidth 1), and a circle (radius 3.5px, fill `#c2956b`) at the handle tip
  - If `segment.handleOut` is not zero: same pattern for handleOut
- Return nothing (side effect: populates handleLayer)

Export `syncPathToProfile(path, transform)`:
- Read the Paper.js path segments and convert back to profile data model format
- For each segment `i`:
  - `x` and `y` from `transform.toProfile(segment.point)` -- round to 2 decimal places
  - Determine `type`: if segment has a non-zero `handleIn` OR the previous segment has a non-zero `handleOut` for the curve leading to this segment, it is `'bezier'`; otherwise `'line'`
  - For `bezier` type: compute `cp1` (absolute) from previous segment's `handleOut`: `transform.toProfile(prevSegment.point.add(prevSegment.handleOut))`, and `cp2` (absolute) from this segment's `handleIn`: `transform.toProfile(segment.point.add(segment.handleIn))`
- Return the array of profile point objects
- IMPORTANT: Round x and y to 2 decimal places using `Math.round(val * 100) / 100` to avoid floating-point drift

**4. Create `js/profileEditor.js`:**

Main editor module that wires everything together.

Export `initProfileEditor(canvasId, options)`:
- `options.initialProfile` -- the profile data object (default: getTestProfile())
- `options.onChange(profileData)` -- callback when profile changes (for 3D preview update)
- Call `initCanvas(canvasId)` to get `{ project, view, layers }`
- Call `createTransform(view.size.width, view.size.height)` -- use default bounds for now
- Call `renderProfile(initialProfile.points, transform, layers.profile)` to create the path
- Call `renderHandles(path, layers.handles)` to show control points
- Store references: `currentPath`, `currentTransform`, `layers`, `onChange`
- Handle canvas resize: on `view.onResize`, recalculate transform and re-render
- Return public API: `{ getProfileData(), setProfileData(profile), getTransform(), getLayers() }`

Export `getProfileData()`:
- Call `syncPathToProfile(currentPath, currentTransform)` to read current state
- Return `createProfile(points)` wrapping the points

Export `setProfileData(profile)`:
- Clear and re-render the path from the new profile data
- Call `renderHandles` to update decorators

Internal function `notifyChange()`:
- Call `syncPathToProfile` to get current points
- Call `options.onChange(createProfile(points))` to notify app.js
- This is called after every edit operation (drag end, point add, point delete)

**5. Update `css/style.css`:**

Add styles for the editor panel:
```css
#editor-container {
  flex: 2;
  position: relative;
  min-height: 500px;
  background-color: #faf8f5;
  border-right: 1px solid var(--border);
}

#editor-container canvas {
  display: block;
  width: 100% !important;
  height: 100% !important;
}

#editor-toolbar {
  position: absolute;
  top: 8px;
  left: 8px;
  z-index: 10;
  display: flex;
  gap: 4px;
  background: rgba(255,255,255,0.9);
  padding: 4px;
  border-radius: 6px;
  border: 1px solid var(--border);
}

.tool-btn {
  padding: 0.4rem 0.7rem;
  font-size: 0.8rem;
  background: white;
  color: var(--dark);
  border: 1px solid var(--border);
}

.tool-btn.active {
  background: var(--terra-cotta);
  color: var(--cream);
  border-color: var(--terra-cotta);
}
```

Change `#preview-container` from `flex: 2` to `flex: 1.5` so editor and preview share space.

At the 768px responsive breakpoint, stack all three panels vertically.
  </action>
  <verify>
Open `index.html` in browser. Verify:
1. Paper.js canvas appears in the left panel showing the test cup profile as a bezier path
2. Anchor points (dark circles) and bezier control handles (terra cotta circles with lines) are visible
3. The revolution axis (x=0) line position is at the left margin
4. The 3D preview still renders on the right
5. No console errors about Paper.js or coordinate transforms
6. Canvas resizes correctly when window is resized
  </verify>
  <done>
The test cup profile from Phase 1 renders as a Paper.js bezier path on a 2D canvas with visible anchor points and control handles. The coordinate system correctly maps mm to canvas pixels with Y-axis flipped. The 3D preview panel continues to work alongside the new editor panel.
  </done>
</task>

<task type="auto">
  <name>Task 2: Edit tool (drag points/handles), draw tool (add/delete points), and app wiring</name>
  <files>
    js/profileEditor/editTool.js
    js/profileEditor/drawTool.js
    js/profileEditor.js
    js/app.js
  </files>
  <action>
**1. Create `js/profileEditor/editTool.js`:**

Export `createEditTool(editorState)`:
- `editorState` provides: `getPath()`, `getTransform()`, `getLayers()`, `notifyChange()`, `requestRender()`
- Create `new paper.Tool()` and assign event handlers

**`onMouseDown(event)`:**
- Run `paper.project.hitTest(event.point, { segments: true, handles: true, stroke: true, curves: true, fill: false, tolerance: 8 })`
- If no hit, deselect all (clear any selection highlight)
- If hit type is `'segment'`: store `selectedSegment = hitResult.segment`, store `dragStart = event.point.clone()`
- If hit type is `'handle-in'`: store `selectedHandle = { segment: hitResult.segment, type: 'handleIn' }`
- If hit type is `'handle-out'`: store `selectedHandle = { segment: hitResult.segment, type: 'handleOut' }`
- If hit type is `'stroke'` or `'curve'`: insert a new point on the curve using `editorState.getPath().divideAt(hitResult.location)`. After inserting, call `editorState.requestRender()` to update handle decorators. Call `editorState.notifyChange()`.

**`onMouseDrag(event)`:**
- If `selectedSegment`: move it by `event.delta` -- `selectedSegment.point = selectedSegment.point.add(event.delta)`
- If `selectedHandle`: move the handle -- `selectedHandle.segment[selectedHandle.type] = selectedHandle.segment[selectedHandle.type].add(event.delta)`
- After either: call `editorState.requestRender()` to update handle layer
- Do NOT call `notifyChange()` on every drag frame (would spam 3D preview). The 3D update happens on mouseUp.

**`onMouseUp(event)`:**
- If anything was dragged (selectedSegment or selectedHandle existed and moved), call `editorState.notifyChange()` (triggers 3D preview update + future undo snapshot)
- Clear selection: `selectedSegment = null`, `selectedHandle = null`

**`onKeyDown(event)`:**
- If key is `Backspace` or `Delete` and there is a `lastSelectedSegment` (track last clicked segment):
  - If path has more than 2 segments (minimum for a valid profile): remove the segment via `lastSelectedSegment.remove()`
  - Call `editorState.requestRender()` and `editorState.notifyChange()`

- Return `{ tool, activate: () => tool.activate() }`

**2. Create `js/profileEditor/drawTool.js`:**

Export `createDrawTool(editorState)`:
- `editorState` provides same interface as editTool
- Create `new paper.Tool()`

**`onMouseDown(event)`:**
- Convert click position to profile coordinates using `editorState.getTransform().toProfile(event.point)`
- Determine where to insert the new point in the profile: find the segment in the path closest to the click (using `editorState.getPath().getNearestLocation(event.point)`)
- Insert a new segment at that curve location using `editorState.getPath().divideAt(location)`
- Call `editorState.requestRender()` and `editorState.notifyChange()`
- The new point is initially a `line` type (no bezier handles). The user can switch to edit tool and drag handles to make it a bezier curve.

Alternative simpler approach: In draw mode, clicking on the canvas appends a new point to the END of the path (extends the profile upward). The anchor is placed at the clicked position. This is more intuitive for "drawing" a profile from bottom to top.
- If the click y-coordinate (in profile mm) is above the last point's y, append to end
- If below the first point's y, prepend to start
- Otherwise, insert at nearest curve location (same as edit tool stroke click)

**`onMouseUp(event)`:**
- Finalize any pending operation
- Return `{ tool, activate: () => tool.activate() }`

**3. Update `js/profileEditor.js`:**

After creating the canvas and rendering the initial profile, create both tools:
```javascript
const editTool = createEditTool(editorState);
const drawTool = createDrawTool(editorState);
```

The `editorState` object passed to tools:
```javascript
const editorState = {
  getPath: () => currentPath,
  getTransform: () => currentTransform,
  getLayers: () => layers,
  notifyChange: () => { /* sync path to data, call onChange */ },
  requestRender: () => { renderHandles(currentPath, layers.handles); },
};
```

Wire tool switching to the toolbar buttons:
```javascript
document.getElementById('btn-edit-tool').addEventListener('click', () => {
  editTool.activate();
  document.getElementById('btn-edit-tool').classList.add('active');
  document.getElementById('btn-draw-tool').classList.remove('active');
});
document.getElementById('btn-draw-tool').addEventListener('click', () => {
  drawTool.activate();
  document.getElementById('btn-draw-tool').classList.add('active');
  document.getElementById('btn-edit-tool').classList.remove('active');
});
```

Activate edit tool by default on init.

**4. Update `js/app.js`:**

Add import: `import { initProfileEditor } from './profileEditor.js';`

In the `DOMContentLoaded` handler, AFTER the WASM init and auto-revolve:
```javascript
// Initialize profile editor with test profile
const editor = initProfileEditor('profile-canvas', {
  initialProfile: getTestProfile(),
  onChange: async (profile) => {
    // Debounced 3D preview update using existing cancellation bridge
    const result = await geometryBridge.generateWithCancellation(profile.points);
    if (result) {
      preview3d.updateMesh(result);
    }
  },
});
```

Actually, initialize the editor BEFORE WASM init (Paper.js loads synchronously from CDN, no async needed). The editor can display the profile immediately while WASM loads in the background. The `onChange` callback will trigger 3D updates once WASM is ready (generateWithCancellation will queue until init completes or will error gracefully -- add a guard: only call generateWithCancellation if `geometryBridge.isReady()`).

Update the onChange callback with a guard:
```javascript
onChange: async (profile) => {
  if (!geometryBridge.isReady()) return; // WASM not ready yet
  const result = await geometryBridge.generateWithCancellation(profile.points);
  if (result) {
    preview3d.updateMesh(result);
  }
},
```
  </action>
  <verify>
Open `index.html` in browser. Test the following interactions:
1. **Edit tool (default):** Click and drag an anchor point -- point moves, profile reshapes
2. **Edit tool:** Click and drag a bezier handle -- curve shape changes while anchor stays fixed
3. **Edit tool:** Click on a curve segment -- a new point appears at the click location
4. **Edit tool:** Select a point, press Delete/Backspace -- point is removed and curve adjusts
5. **Draw tool:** Click toolbar "Draw" button -- tool switches (button highlights). Click on canvas -- new point added to profile
6. **Tool switching:** Click between Edit and Draw buttons -- active button highlights correctly
7. **3D update:** After dragging a point and releasing mouse, the 3D preview updates (if WASM loaded). Check console for generateWithCancellation calls.
8. No errors in console during any interaction
  </verify>
  <done>
Users can interactively edit the pot profile: drag anchor points, drag bezier control handles, insert new points on curve segments, delete points. The edit tool and draw tool switch via toolbar buttons. Profile changes propagate to the 3D preview via generateWithCancellation. Requirements PROF-01 (draw with bezier curves) and PROF-02 (edit by dragging, adding, removing points) are satisfied.
  </done>
</task>

</tasks>

<verification>
1. Profile editor canvas renders the test cup profile with correct geometry (foot at bottom, rim at top, belly curve in between)
2. Y-axis orientation correct: profile foot is at bottom of canvas, rim at top
3. Bezier curves render smoothly between anchor points
4. Handle decorators (circles + lines) match the control points from the profile data model
5. Dragging an anchor point and releasing triggers a 3D preview update
6. Point insertion creates a valid new point that the profile data model can represent
7. Point deletion removes the point and the profile remains valid (min 2 points)
8. Tool switching works via toolbar buttons
9. No memory leaks from repeated edit operations (handles layer cleans up on re-render)
10. `syncPathToProfile` round-trips correctly: render profile -> edit -> sync back -> render again produces same visual
</verification>

<success_criteria>
- User can see the test cup profile rendered as bezier curves on a Paper.js canvas
- User can drag points and handles to reshape the profile
- User can add points by clicking on curve segments
- User can delete points with Backspace/Delete
- Profile changes trigger 3D preview updates when WASM is ready
- No console errors during normal operation
- Requirements PROF-01 and PROF-02 are functionally complete
</success_criteria>

<output>
After completion, create `.planning/phases/phase-2/02-01-SUMMARY.md`
</output>
