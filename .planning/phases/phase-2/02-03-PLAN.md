---
phase: 02-profile-editor-core
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - js/profileEditor/undoManager.js
  - js/profileEditor/gridOverlay.js
  - js/profileEditor/dimensionOverlay.js
  - js/profileEditor.js
  - index.html
  - css/style.css
autonomous: true

must_haves:
  truths:
    - "User presses Cmd+Z (or Ctrl+Z) and the profile reverts to the previous edit state"
    - "User presses Cmd+Shift+Z (or Ctrl+Shift+Z) and the profile restores the undone state"
    - "Grid lines appear behind the profile at regular mm intervals"
    - "When snap-to-grid is enabled, dragged points snap to the nearest grid intersection"
    - "Measurement labels show the current height (mm) and rim diameter (mm) of the profile"
    - "User can type a precise height or rim diameter value and the profile scales to match"
  artifacts:
    - path: "js/profileEditor/undoManager.js"
      provides: "State-snapshot undo/redo manager"
      exports: ["createUndoManager"]
    - path: "js/profileEditor/gridOverlay.js"
      provides: "Grid rendering and snap-to-grid logic"
      exports: ["renderGrid", "snapToGrid", "snapProfilePoint"]
    - path: "js/profileEditor/dimensionOverlay.js"
      provides: "Measurement labels and dimension input handling"
      exports: ["renderDimensions", "applyDimensionInput"]
  key_links:
    - from: "js/profileEditor.js"
      to: "js/profileEditor/undoManager.js"
      via: "pushes profile snapshots on each edit, restores on undo/redo"
      pattern: "undoManager\\.push|undoManager\\.undo|undoManager\\.redo"
    - from: "js/profileEditor.js"
      to: "document keydown listener"
      via: "Cmd+Z / Cmd+Shift+Z keyboard shortcuts bound on document, not Paper.js Tool"
      pattern: "addEventListener.*keydown.*metaKey.*z"
    - from: "js/profileEditor/gridOverlay.js"
      to: "js/profileEditor/canvasSetup.js"
      via: "uses transform to position grid lines at mm intervals"
      pattern: "transform\\.toCanvas|transform\\.scale"
    - from: "js/profileEditor/dimensionOverlay.js"
      to: "js/profileEditor.js"
      via: "applyDimensionInput scales profile points and calls setProfileData"
      pattern: "setProfileData|applyDimensionInput"
---

<objective>
Add undo/redo with keyboard shortcuts, snap-to-grid overlay, measurement labels, and precise dimension input to the profile editor. These are the polish features that make the editor usable for precise pottery work.

Purpose: Potters need to experiment freely (undo), work precisely (grid + snap), and hit exact target dimensions (dimension input). These features together make the difference between a toy and a tool. Satisfies PROF-08, PROF-10, PROF-11.

Output: Undo/redo system, grid overlay with snap toggle, measurement annotations, and dimension input fields.
</objective>

<execution_context>
@/Users/victorhome_1/.claude/get-shit-done/workflows/execute-plan.md
@/Users/victorhome_1/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/phase-2/RESEARCH.md
@.planning/phases/phase-2/02-01-SUMMARY.md
@js/profileData.js
@js/profileEditor.js
@js/profileEditor/canvasSetup.js
@js/profileEditor/pathRenderer.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Undo/redo manager with keyboard shortcuts and grid overlay with snap</name>
  <files>
    js/profileEditor/undoManager.js
    js/profileEditor/gridOverlay.js
    js/profileEditor.js
    index.html
    css/style.css
  </files>
  <action>
**1. Create `js/profileEditor/undoManager.js`:**

Export `createUndoManager(maxHistory = 100)`:
- Internal state: `history = []` (array of deep-cloned profile data objects), `currentIndex = -1`

Methods:
- `push(profileData)`: Discard any redo states (slice history to `currentIndex + 1`). Deep clone the profile data via `JSON.parse(JSON.stringify(profileData))`. Push to history array. Increment currentIndex. If history exceeds maxHistory, shift (remove oldest) and decrement currentIndex.
- `undo()`: If `currentIndex <= 0`, return `null` (nothing to undo). Decrement currentIndex. Return deep clone of `history[currentIndex]`.
- `redo()`: If `currentIndex >= history.length - 1`, return `null` (nothing to redo). Increment currentIndex. Return deep clone of `history[currentIndex]`.
- `canUndo()`: Returns `currentIndex > 0`.
- `canRedo()`: Returns `currentIndex < history.length - 1`.
- `clear()`: Reset history and currentIndex.

Why state-snapshot over command pattern: The profile data model is tiny (~1KB per snapshot per research). 100 snapshots = ~100KB. Command pattern would require inverse operations for every edit type (bezier handle drags, point insertions, deletions) -- complex and bug-prone. Snapshots are trivially correct.

**2. Create `js/profileEditor/gridOverlay.js`:**

Export `renderGrid(gridLayer, transform, canvasWidth, canvasHeight)`:
- Activate `gridLayer`, remove all children
- Determine grid spacing in mm based on zoom level (`transform.scale` = pixels per mm):
  - If scale < 2: spacing = 10mm (zoomed out)
  - If scale < 5: spacing = 5mm
  - If scale < 15: spacing = 2mm
  - Else: spacing = 1mm (zoomed in)
- Define colors: `gridColor = '#e8e5e0'` (subtle), `gridMajorColor = '#d5d0ca'` (every 10mm), `axisColor = '#c2956b'` (revolution axis at x=0, terra cotta)

- Draw vertical lines at x = 0, gridSpacing, 2*gridSpacing, ... up to 100mm:
  - Convert each x (mm) to canvas x via `transform.toCanvas(x, 0).x`
  - Skip if canvas x is outside [0, canvasWidth]
  - At x=0: thick terra cotta line (strokeWidth 2, strokeColor axisColor) -- this is the revolution axis
  - At multiples of 10mm: medium line (strokeWidth 0.75, gridMajorColor)
  - Otherwise: thin line (strokeWidth 0.5, gridColor)
  - Use `new paper.Path.Line({ from, to, strokeColor, strokeWidth })`

- Draw horizontal lines at y = 0, gridSpacing, 2*gridSpacing, ... up to 200mm:
  - Convert each y (mm) to canvas y via `transform.toCanvas(0, y).y`
  - Skip if canvas y is outside [0, canvasHeight]
  - At y=0: slightly thicker line (this is the base line)
  - At multiples of 10mm: medium line
  - Otherwise: thin line

- Add axis label "x=0" near the revolution axis line (small text at top of the axis line) using `new paper.PointText({ point, content: 'axis', fontSize: 9, fillColor: axisColor })`

Export `snapToGrid(value, gridSpacing)`:
- Returns `Math.round(value / gridSpacing) * gridSpacing`
- Simple nearest-grid-point snap

Export `snapProfilePoint(profilePoint, gridSpacing, snapEnabled)`:
- If `!snapEnabled`, return profilePoint unchanged
- Return `{ ...profilePoint, x: snapToGrid(profilePoint.x, gridSpacing), y: snapToGrid(profilePoint.y, gridSpacing) }`
- Also snap cp1 and cp2 if they exist: `cp1: { x: snapToGrid(cp1.x, gridSpacing), y: snapToGrid(cp1.y, gridSpacing) }`

**3. Update `js/profileEditor.js`:**

Import undoManager and gridOverlay:
```javascript
import { createUndoManager } from './profileEditor/undoManager.js';
import { renderGrid, snapToGrid } from './profileEditor/gridOverlay.js';
```

**Undo/redo integration:**
- Create the undo manager at init: `const undoManager = createUndoManager(100);`
- Push initial state: `undoManager.push(initialProfile);`
- In `notifyChange()`, AFTER syncing profile, push to undo stack: `undoManager.push(profile);`
- Bind keyboard shortcuts on `document` (NOT Paper.js Tool -- shortcuts work regardless of active tool):

```javascript
document.addEventListener('keydown', (e) => {
  // Undo: Cmd+Z (Mac) or Ctrl+Z (Windows/Linux)
  if ((e.metaKey || e.ctrlKey) && e.key === 'z' && !e.shiftKey) {
    e.preventDefault();
    const state = undoManager.undo();
    if (state) {
      setProfileData(state);
      // Trigger 3D preview update
      if (options.onChange) options.onChange(state);
    }
  }
  // Redo: Cmd+Shift+Z (Mac) or Ctrl+Shift+Z (Windows/Linux) or Ctrl+Y (Windows)
  if (((e.metaKey || e.ctrlKey) && e.key === 'z' && e.shiftKey) ||
      (e.ctrlKey && e.key === 'y')) {
    e.preventDefault();
    const state = undoManager.redo();
    if (state) {
      setProfileData(state);
      if (options.onChange) options.onChange(state);
    }
  }
});
```

IMPORTANT: `setProfileData` re-renders the path and handles from the restored profile. It must NOT push to the undo stack itself (otherwise undo/redo would create infinite loops). Add a flag or separate internal method: `_setProfileDataInternal(profile, { pushUndo: false })`.

**Grid integration:**
- After canvas init, render the grid: `renderGrid(layers.grid, transform, view.size.width, view.size.height);`
- On canvas resize, re-render the grid
- Store `snapEnabled = false` and `gridSpacing = 1` (mm) as editor state
- Expose `setSnapEnabled(enabled)` and `getSnapEnabled()` in the editor public API

**Snap integration with edit tool:**
- Pass `snapEnabled` and `gridSpacing` to the editor state object so the edit tool can access them
- In the edit tool, when a point drag ends (onMouseUp), if snap is enabled:
  - Convert the final point position to profile coords
  - Snap to grid: `snapped = snapToGrid(profileCoord.x, gridSpacing)`, same for y
  - Convert back to canvas coords and set the segment point
  - This snaps the final position, not every drag frame (smoother UX)

**4. Update `index.html`:**

Add snap toggle and undo/redo buttons to the editor toolbar:
```html
<div id="editor-toolbar">
  <button id="btn-edit-tool" class="tool-btn active" title="Edit points and handles">Edit</button>
  <button id="btn-draw-tool" class="tool-btn" title="Add points to profile">Draw</button>
  <span class="toolbar-divider"></span>
  <button id="btn-undo" class="tool-btn" title="Undo (Cmd+Z)" disabled>Undo</button>
  <button id="btn-redo" class="tool-btn" title="Redo (Cmd+Shift+Z)" disabled>Redo</button>
  <span class="toolbar-divider"></span>
  <label class="snap-toggle" title="Snap to grid">
    <input type="checkbox" id="chk-snap"> Snap
  </label>
</div>
```

Wire the undo/redo buttons in profileEditor.js:
```javascript
document.getElementById('btn-undo')?.addEventListener('click', () => { /* same as Cmd+Z handler */ });
document.getElementById('btn-redo')?.addEventListener('click', () => { /* same as Cmd+Shift+Z handler */ });
document.getElementById('chk-snap')?.addEventListener('change', (e) => { snapEnabled = e.target.checked; });
```

Update undo/redo button disabled state after each notifyChange and after each undo/redo:
```javascript
function updateUndoRedoButtons() {
  const undoBtn = document.getElementById('btn-undo');
  const redoBtn = document.getElementById('btn-redo');
  if (undoBtn) undoBtn.disabled = !undoManager.canUndo();
  if (redoBtn) redoBtn.disabled = !undoManager.canRedo();
}
```

**5. Update `css/style.css`:**

Add toolbar divider and snap toggle styles:
```css
.toolbar-divider {
  width: 1px;
  height: 20px;
  background: var(--border);
  margin: 0 2px;
  align-self: center;
}

.snap-toggle {
  display: flex;
  align-items: center;
  gap: 4px;
  font-size: 0.8rem;
  color: var(--dark);
  cursor: pointer;
  padding: 0 4px;
}

.snap-toggle input {
  cursor: pointer;
}
```
  </action>
  <verify>
Test in browser:

1. **Undo:** Edit the profile (drag a point). Press Cmd+Z (or Ctrl+Z). The profile reverts to the previous state. The 3D preview also updates.

2. **Redo:** After undoing, press Cmd+Shift+Z. The profile restores the undone state.

3. **Multiple undo levels:** Make 5 edits. Undo 3 times. Verify each undo step restores the correct state. Make a new edit -- this should discard the 2 remaining redo states.

4. **Undo button state:** After initial load, Undo button is disabled. After one edit, Undo is enabled. After undoing all, Undo is disabled again. Redo enables/disables correctly.

5. **Grid:** Grid lines visible behind the profile. Revolution axis (x=0) is terra cotta colored and thicker.

6. **Snap-to-grid:** Check the "Snap" checkbox. Drag a point and release. The point should snap to the nearest grid intersection. Verify by checking the status or coordinates that the values are round numbers.

7. **No keyboard conflicts:** Undo/redo shortcuts do not interfere with browser undo (e.g., in text fields). The preventDefault only fires when the editor is focused.
  </verify>
  <done>
Undo/redo works via Cmd+Z / Cmd+Shift+Z with up to 100 history levels. Grid overlay renders at mm intervals behind the profile. Snap-to-grid toggle snaps point positions to grid intersections. Undo/redo toolbar buttons reflect state. Requirements PROF-08 (undo/redo) and PROF-10 (snap-to-grid and measurement overlays -- grid portion) are satisfied.
  </done>
</task>

<task type="auto">
  <name>Task 2: Measurement overlays and precise dimension input</name>
  <files>
    js/profileEditor/dimensionOverlay.js
    js/profileEditor.js
    index.html
    css/style.css
  </files>
  <action>
**1. Create `js/profileEditor/dimensionOverlay.js`:**

This module renders measurement annotations on the canvas and handles dimension input from HTML fields.

Export `renderDimensions(profilePoints, overlayLayer, transform)`:
- Activate `overlayLayer` (but do NOT clear it -- constraints.js also uses this layer. Use a named group: `overlayLayer.children['dimensions']?.remove()` then create `new paper.Group({ name: 'dimensions', parent: overlayLayer })`)
- Calculate key dimensions from profile points:
  - `height` = max(y) - min(y) of all profile points (in mm)
  - `rimDiameter` = 2 * x of the last point (topmost, highest y) -- rim is the last point in a foot-to-rim profile
  - `maxDiameter` = 2 * max(x) of all profile points (the widest part / belly)
  - `footDiameter` = 2 * x of the first point (bottommost)
- Render dimension lines and labels:

  **Height dimension (vertical, on the right side):**
  - Draw a vertical line from the bottom point to the top point, offset ~15px to the right of the rightmost profile point
  - Convert: `lineX = transform.toCanvas(maxRadiusMm + 5, 0).x` (5mm right of widest point)
  - Top arrow: `transform.toCanvas(0, height).y`, Bottom arrow: `transform.toCanvas(0, 0).y`
  - Draw small horizontal ticks at top and bottom endpoints
  - Add label at midpoint: `new paper.PointText({ point: midpoint, content: height.toFixed(1) + ' mm', fontSize: 10, fillColor: '#666', justification: 'left' })`

  **Rim diameter dimension (horizontal, at the top):**
  - Draw a horizontal line from x=0 to x=rimRadius at the rim height, offset ~10px above the rim point
  - Label: `rimDiameter.toFixed(1) + ' mm dia'`
  - Position at `transform.toCanvas(rimRadius / 2, rimHeight + 3)` (centered above the rim, with "dia" suffix)

  **Belly diameter dimension (horizontal, at widest point, only if different from rim by >2mm):**
  - Draw horizontal line from x=0 to x=maxRadius at the y-height of the widest point
  - Label: `maxDiameter.toFixed(1) + ' mm'`
  - Only render if belly diameter differs from rim diameter by more than 2mm (avoid clutter)

  **Foot diameter dimension (horizontal, at the bottom):**
  - Draw horizontal line from x=0 to x=footRadius at the bottom
  - Label: `footDiameter.toFixed(1) + ' mm'`

- Dimension line styling: strokeColor `#999`, strokeWidth 0.75, dashed (`dashArray: [3, 3]`)
- Arrow tips: small triangles at line endpoints (3px size) or simple perpendicular ticks
- Labels: fontSize 10, fillColor `#666`, fontFamily system sans-serif

Export `getDimensions(profilePoints)`:
- Pure function (no Paper.js dependency) that returns `{ height, rimDiameter, maxDiameter, footDiameter }` in mm
- Used by both the overlay renderer and the dimension input handler

Export `applyDimensionInput(profilePoints, dimension, newValue)`:
- `dimension` is one of `'height'`, `'rimDiameter'`
- Returns a NEW array of profile points (does not mutate input)

For **height** change:
- Current height = max(y) - min(y)
- Scale factor = newValue / currentHeight
- Scale all y-coordinates: `point.y = minY + (point.y - minY) * scaleFactor`
- Also scale bezier control point y-coords: `cp1.y`, `cp2.y`
- This uniformly stretches/compresses the profile vertically

For **rimDiameter** change:
- The rim is the last point (highest y). New rim radius = newValue / 2.
- Current rim radius = last point's x
- Scale factor = newRimRadius / currentRimRadius
- Scale all x-coordinates proportionally: `point.x = point.x * scaleFactor`
- Also scale bezier control point x-coords: `cp1.x`, `cp2.x`
- This uniformly stretches/compresses the profile horizontally
- Note: this is a simple proportional scale. A smarter approach would only move the rim point and interpolate, but proportional scale is correct for the MVP and matches user expectations (changing rim size scales the whole pot proportionally).

**2. Update `index.html`:**

Add dimension input panel below the editor toolbar or in the controls sidebar. Place it in the controls sidebar for now (inside `aside#controls`), before the Phase 1 test buttons:

```html
<div id="dimension-inputs">
  <h3>Dimensions</h3>
  <div class="dim-field">
    <label for="input-height">Height</label>
    <div class="dim-input-group">
      <input type="number" id="input-height" step="0.5" min="1" max="500" />
      <span class="dim-unit">mm</span>
    </div>
  </div>
  <div class="dim-field">
    <label for="input-rim-diameter">Rim diameter</label>
    <div class="dim-input-group">
      <input type="number" id="input-rim-diameter" step="0.5" min="1" max="500" />
      <span class="dim-unit">mm</span>
    </div>
  </div>
  <div class="dim-readout">
    <span>Belly: <strong id="readout-belly">--</strong> mm</span>
    <span>Foot: <strong id="readout-foot">--</strong> mm</span>
  </div>
</div>
```

Height and rim diameter are INPUT fields (user can type). Belly and foot are read-only displays.

**3. Update `js/profileEditor.js`:**

Import dimension overlay:
```javascript
import { renderDimensions, getDimensions, applyDimensionInput } from './profileEditor/dimensionOverlay.js';
```

**Render dimensions on init and after every change:**
- In `notifyChange()`, after syncing profile, call `renderDimensions(points, layers.overlay, transform)`. This must run AFTER constraint violation rendering -- use the named group approach in dimensionOverlay to avoid overwriting constraint markers.
- Also update the dimension input fields with current values:
```javascript
function updateDimensionInputs(points) {
  const dims = getDimensions(points);
  const heightInput = document.getElementById('input-height');
  const rimInput = document.getElementById('input-rim-diameter');
  const bellyReadout = document.getElementById('readout-belly');
  const footReadout = document.getElementById('readout-foot');

  // Only update if input is not focused (avoid overwriting user's typing)
  if (heightInput && document.activeElement !== heightInput) {
    heightInput.value = dims.height.toFixed(1);
  }
  if (rimInput && document.activeElement !== rimInput) {
    rimInput.value = dims.rimDiameter.toFixed(1);
  }
  if (bellyReadout) bellyReadout.textContent = dims.maxDiameter.toFixed(1);
  if (footReadout) footReadout.textContent = dims.footDiameter.toFixed(1);
}
```

**Wire dimension input change events:**
```javascript
document.getElementById('input-height')?.addEventListener('change', (e) => {
  const newHeight = parseFloat(e.target.value);
  if (isNaN(newHeight) || newHeight <= 0) return;
  const currentPoints = syncPathToProfile(currentPath, currentTransform);
  const newPoints = applyDimensionInput(currentPoints, 'height', newHeight);
  const newProfile = createProfile(newPoints);
  setProfileData(newProfile);
  undoManager.push(newProfile);
  notifyChange();
});

document.getElementById('input-rim-diameter')?.addEventListener('change', (e) => {
  const newDiameter = parseFloat(e.target.value);
  if (isNaN(newDiameter) || newDiameter <= 0) return;
  const currentPoints = syncPathToProfile(currentPath, currentTransform);
  const newPoints = applyDimensionInput(currentPoints, 'rimDiameter', newDiameter);
  const newProfile = createProfile(newPoints);
  setProfileData(newProfile);
  undoManager.push(newProfile);
  notifyChange();
});
```

Use the `'change'` event (fires on Enter or blur), NOT `'input'` (which fires on every keystroke -- would cause constant profile updates while typing).

**Update dimension overlays on init:**
- Call `updateDimensionInputs(initialProfile.points)` after initial render
- Call `renderDimensions(initialProfile.points, layers.overlay, transform)` after initial render

**4. Update `css/style.css`:**

Add dimension input panel styles:
```css
#dimension-inputs {
  margin-bottom: 1rem;
  padding-bottom: 1rem;
  border-bottom: 1px solid var(--border);
}

#dimension-inputs h3 {
  margin: 0 0 0.5rem;
}

.dim-field {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 0.4rem;
}

.dim-field label {
  font-size: 0.85rem;
  color: var(--dark);
}

.dim-input-group {
  display: flex;
  align-items: center;
  gap: 4px;
}

.dim-input-group input {
  width: 70px;
  padding: 0.3rem 0.4rem;
  border: 1px solid var(--border);
  border-radius: 3px;
  font-size: 0.85rem;
  text-align: right;
}

.dim-input-group input:focus {
  border-color: var(--terra-cotta);
  outline: none;
}

.dim-unit {
  font-size: 0.8rem;
  color: #999;
}

.dim-readout {
  display: flex;
  gap: 1rem;
  font-size: 0.8rem;
  color: #666;
  margin-top: 0.5rem;
}
```
  </action>
  <verify>
Test in browser:

1. **Measurement overlays:** Verify dimension lines and labels are visible on the canvas:
   - Height dimension line on the right side with mm label
   - Rim diameter dimension line at the top with mm label
   - Foot diameter at the bottom
   - Labels update when profile is edited (drag a point and release)

2. **Dimension inputs populated:** The height and rim diameter input fields in the sidebar show correct values matching the test profile (~85mm height, ~84mm rim diameter).

3. **Height input:** Type 100 into the height field and press Enter. The profile should scale vertically to 100mm height. The 3D preview should update. All proportions should be preserved.

4. **Rim diameter input:** Type 100 into the rim diameter field and press Enter. The profile should scale horizontally so the rim radius is 50mm (100mm diameter). All proportions should be preserved.

5. **Undo after dimension input:** After changing a dimension, press Cmd+Z. The profile reverts to the pre-change state. The dimension inputs update to reflect the reverted values.

6. **Read-only readouts:** Belly and foot diameter readouts update after edits but are not editable.

7. **Input field behavior:** While typing in a dimension input, the field value does NOT get overwritten by profile updates (the check for `document.activeElement` prevents this).

8. **Overlays coexist with constraints:** Dimension labels and constraint violation markers can appear simultaneously without overwriting each other (both use the overlay layer but in separate groups).
  </verify>
  <done>
Measurement overlays show height, rim diameter, max diameter, and foot diameter with dimension lines and labels on the canvas. Height and rim diameter can be set via precise numeric inputs in the sidebar. Belly and foot diameters are displayed as read-only. Dimension changes push to undo stack and update the 3D preview. Requirements PROF-10 (measurement overlays) and PROF-11 (precise dimension input) are satisfied. Combined with Task 1, PROF-08 (undo/redo) is also satisfied.
  </done>
</task>

</tasks>

<verification>
1. Undo/redo restores exact profile state (all point positions, types, control points)
2. Undo/redo keyboard shortcuts work: Cmd+Z, Cmd+Shift+Z, Ctrl+Z, Ctrl+Y
3. Undo stack correctly discards redo states when a new edit is made
4. Undo/redo button states (enabled/disabled) reflect actual undo/redo availability
5. Grid lines render at correct mm intervals behind the profile
6. Grid spacing adapts to zoom level (fewer lines when zoomed out)
7. Revolution axis (x=0) is visually distinct (terra cotta color, thicker line)
8. Snap-to-grid toggle works: points snap to grid on mouse release when enabled
9. Measurement labels show correct values for the test profile
10. Dimension input fields accept precise values and scale the profile correctly
11. Dimension changes are undoable
12. Dimension overlays and constraint markers coexist on the overlay layer
13. All keyboard shortcuts prevented from bubbling to browser (no accidental browser undo)
</verification>

<success_criteria>
- Cmd+Z undoes the last edit, Cmd+Shift+Z redoes it
- Grid lines are visible behind the profile at mm intervals
- Snap-to-grid toggles on/off and constrains final point positions to grid
- Dimension labels on canvas show height, rim diameter, belly, foot in mm
- Typing a height or rim diameter value and pressing Enter scales the profile
- All dimension changes are undoable
- Requirements PROF-08, PROF-10, and PROF-11 are functionally complete
</success_criteria>

<output>
After completion, create `.planning/phases/phase-2/02-03-SUMMARY.md`
</output>
