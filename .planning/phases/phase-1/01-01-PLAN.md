---
phase: 01-wasm-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - js/workers/geometryWorker.js
  - spike/wasm-spike.html
  - wasm/.gitkeep
autonomous: true

must_haves:
  truths:
    - "replicad ESM bundle loads successfully inside a module Web Worker via direct CDN URL"
    - "opencascade WASM binary initializes via locateFile callback pointing to CDN or self-hosted path"
    - "A hardcoded rectangle can be revolved into a 3D solid and mesh data extracted"
    - "The exact runtime types of shape.mesh() return value are documented (Array vs TypedArray)"
    - "shape.delete() can be called on the revolved solid without error"
  artifacts:
    - path: "spike/wasm-spike.html"
      provides: "Self-contained spike that validates all unknowns"
      min_lines: 50
    - path: "js/workers/geometryWorker.js"
      provides: "Production worker skeleton with validated init and revolve"
      min_lines: 60
  key_links:
    - from: "js/workers/geometryWorker.js"
      to: "replicad CDN URL"
      via: "ESM import statement with full URL"
      pattern: "import.*from.*cdn\\.jsdelivr\\.net.*replicad"
    - from: "js/workers/geometryWorker.js"
      to: "WASM binary"
      via: "locateFile callback in opencascade() init"
      pattern: "locateFile"
---

<objective>
Validate that replicad + replicad-opencascadejs load and operate correctly inside a module Web Worker without a bundler. This is the critical risk gate for the entire project -- if CDN loading fails, we need to identify the fallback before investing in architecture.

Purpose: De-risk the lowest-confidence technical assumption (replicad CDN loading in a worker). Every subsequent plan depends on the findings here. The spike must answer 5 open questions from RESEARCH.md and produce a production-ready worker skeleton.

Output: A working spike HTML file that proves the loading chain works, plus a production worker file (`geometryWorker.js`) with validated init pattern and basic revolve command handler.
</objective>

<execution_context>
@/Users/victorhome_1/.claude/get-shit-done/workflows/execute-plan.md
@/Users/victorhome_1/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/phase-1/RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WASM spike -- validate loading chain and revolve operation</name>
  <files>spike/wasm-spike.html, wasm/.gitkeep</files>
  <action>
Create a self-contained HTML file at `spike/wasm-spike.html` that validates all 5 open questions from Phase 1 RESEARCH.md. This file is a throwaway test harness, not production code.

The spike must:

1. Create a module Web Worker inline (using a Blob URL or a separate minimal worker file at `spike/spike-worker.js`) that:
   - Imports replicad from `https://cdn.jsdelivr.net/npm/replicad@0.20.5/dist/replicad.js` using a direct URL (NOT a bare specifier -- import maps do not work in workers)
   - Imports the opencascade init function from `https://cdn.jsdelivr.net/npm/replicad-opencascadejs@0.20.2/src/replicad_single.js`
   - Calls `opencascade({ locateFile: () => WASM_URL })` where WASM_URL points to `https://cdn.jsdelivr.net/npm/replicad-opencascadejs@0.20.2/src/replicad_single.wasm`
   - Calls `setOC(OC)` after WASM loads
   - Posts a message back to main thread confirming initialization succeeded

2. After init, the worker must:
   - Create a simple rectangle profile using `draw([10, 0]).lineTo([10, 50]).lineTo([0, 50]).lineTo([0, 0]).close()`
   - Call `.sketchOnPlane("XZ").revolve()` on it
   - Call `shape.mesh({ tolerance: 0.1, angularTolerance: 0.3 })` on the result
   - Log and post back to main thread:
     a. `typeof meshData.vertices` and `Array.isArray(meshData.vertices)` (answer open question #2)
     b. `meshData.vertices.length` (to verify data exists)
     c. Whether `meshData.normals` and `meshData.triangles` exist
     d. The keys of the meshData object
   - Call `shape.delete()` and confirm no error (answer open question #3)
   - Call `shape.mesh()` return value inspection (answer open question #2)

3. The main thread HTML should:
   - Display a status div showing: "Loading WASM...", "WASM Ready", "Revolve Complete", or error messages
   - Log all findings to both console and the page
   - Time the WASM initialization (performance.now())
   - Time the revolve + mesh operation

4. Handle FALLBACKS for the most likely failure modes:
   - If `import opencascade from '...'` fails because `replicad_single.js` is not ESM: try fetching the file and checking if it starts with `export` or `module.exports` (answer open question #5). Log the finding. If not ESM, try `importScripts()` in a classic worker as fallback.
   - If replicad.js has internal bare specifier imports that fail: log the exact error message. This tells us if we need esm.sh or a self-hosted bundle.

5. Also validate the revolve axis question (open question #4):
   - After the simple rectangle revolve, try a cup-like profile:
     ```javascript
     draw([30, 0]).lineTo([30, 3]).lineTo([25, 5]).lineTo([35, 50]).lineTo([40, 80]).lineTo([42, 85]).lineTo([0, 85]).lineTo([0, 0]).close().sketchOnPlane("XZ").revolve()
     ```
   - Report whether this produces a valid mesh (vertices.length > 0)

Create an empty `wasm/.gitkeep` file as a placeholder for the directory that will hold self-hosted WASM files if CDN loading fails.

IMPORTANT: The worker MUST use `new Worker(url, { type: 'module' })` for ESM imports. If the spike needs a separate worker file, put it at `spike/spike-worker.js`.

CRITICAL DETAIL: The replicad `draw()` function takes a starting point as `[x, y]`. The `cubicBezierCurveTo` signature is `cubicBezierCurveTo([endX, endY], [cp1X, cp1Y], [cp2X, cp2Y])`. Verify this matches the actual API by checking console output.
  </action>
  <verify>
Open spike/wasm-spike.html in a browser (Chrome preferred) via a local HTTP server (`npx serve .` or `python3 -m http.server`). The page should display:
1. "WASM initialized in Xms" (where X is typically 3000-15000ms)
2. "Rectangle revolve: Y vertices" (Y should be > 0, typically 1000+)
3. "Cup profile revolve: Z vertices" (Z should be > 0)
4. The mesh data type findings (Array vs TypedArray)
5. No errors in the browser console related to module loading or WASM

If WASM CDN loading fails with CORS or MIME type errors, the page should display the specific error message and suggest self-hosting.
  </verify>
  <done>
All 5 open questions from RESEARCH.md are answered:
1. replicad ESM loading in worker: confirmed working OR specific failure mode documented with fallback
2. shape.mesh() return type: exact types logged (number[] vs Float32Array etc.)
3. shape.delete() behavior: confirmed working without error after revolve
4. Z-axis revolve for XZ-plane profiles: confirmed working with cup-like profile
5. replicad_single.js module format: ESM vs CommonJS determined
  </done>
</task>

<task type="auto">
  <name>Task 2: Create production geometryWorker.js from validated spike findings</name>
  <files>js/workers/geometryWorker.js</files>
  <action>
Using the findings from Task 1, create the production `js/workers/geometryWorker.js` file. This is the Web Worker that will be used throughout the project.

The worker must:

1. Import replicad and opencascade using the VALIDATED loading pattern from the spike. Use whichever approach worked:
   - PREFERRED: Direct CDN URL ESM imports with `{ type: 'module' }` worker
   - FALLBACK 1: Self-hosted JS files with relative paths
   - FALLBACK 2: `importScripts()` with classic worker if ESM fails

2. Implement initialization:
   ```javascript
   let loaded = false;
   let initPromise = null;

   async function initialize() {
     if (loaded) return;
     if (initPromise) return initPromise;
     initPromise = (async () => {
       self.postMessage({ type: 'progress', stage: 'downloading', percent: 0 });
       const OC = await opencascade({ locateFile: () => WASM_URL });
       self.postMessage({ type: 'progress', stage: 'ready', percent: 100 });
       loaded = true;
       setOC(OC);
     })();
     return initPromise;
   }
   ```

3. Implement message handler with command routing:
   - `init`: Wait for initialization, respond with `{ ready: true }`
   - `revolve`: Accept `profilePoints` array, build drawing, revolve, extract mesh, respond with mesh data. Use Transferable ArrayBuffers for the response.
   - Unknown commands: Respond with error message

4. Implement the `revolveProfile(points)` function that:
   - Takes an array of `{x, y, type, cp1?, cp2?}` profile points
   - Builds a drawing using `draw([points[0].x, points[0].y])` then iterating:
     - For `type: 'line'`: `.lineTo([pt.x, pt.y])`
     - For `type: 'bezier'`: `.cubicBezierCurveTo([pt.x, pt.y], [pt.cp1.x, pt.cp1.y], [pt.cp2.x, pt.cp2.y])`
   - Closes the profile back to the axis: `.lineTo([0, lastPoint.y]).lineTo([0, points[0].y]).close()`
   - Places on XZ plane: `.sketchOnPlane("XZ")`
   - Revolves: `.revolve()`
   - Extracts mesh with `shape.mesh({ tolerance: 0.1, angularTolerance: 0.3 })`
   - Converts mesh data to typed arrays (Float32Array for vertices/normals, Uint32Array for triangles) based on the spike findings about return types
   - Calls `shape.delete()` to free WASM memory
   - Returns `{ vertices, normals, triangles }`

5. Start initialization immediately on worker load (do not wait for first message):
   ```javascript
   initialize();
   ```

6. Include clear comments documenting:
   - Which loading pattern was used and why (based on spike results)
   - The WASM URL (CDN or self-hosted)
   - That import maps do NOT work in workers
   - That shapes must be `.delete()`d to prevent WASM memory leaks

Do NOT implement the withCleanup() memory management wrapper yet -- that comes in Plan 01-02. For now, just call shape.delete() directly after extracting mesh data.

Do NOT implement cancellation logic yet -- that comes in Plan 01-02.

Do NOT implement edge mesh extraction yet -- just vertices, normals, and triangles for faces.
  </action>
  <verify>
The file `js/workers/geometryWorker.js` exists and:
1. Has imports using the validated pattern from the spike
2. Has an `initialize()` function that loads WASM with progress reporting
3. Has `self.onmessage` handler routing `init` and `revolve` commands
4. Has `revolveProfile(points)` function handling both line and bezier point types
5. Uses Transferable ArrayBuffers in postMessage for mesh data
6. Calls `shape.delete()` after mesh extraction
7. Starts initialization on load
  </verify>
  <done>
Production worker file exists with validated loading pattern, init with progress, revolve command handler, proper mesh data transfer, and basic memory cleanup. Ready for the geometry bridge (Plan 01-02) to communicate with it.
  </done>
</task>

</tasks>

<verification>
Phase 1 Plan 01 is verified when:
1. The spike answers all 5 open questions (logged to console and displayed on page)
2. The production worker loads WASM successfully (can be tested by importing it from a test HTML page)
3. The production worker can revolve a profile and return mesh data
4. No CORS, MIME type, or module loading errors in console
</verification>

<success_criteria>
- replicad loads in a module worker from CDN (or fallback path is documented and implemented)
- WASM initializes with locateFile callback
- A profile can be revolved and mesh data extracted
- shape.delete() works without error
- All open questions from RESEARCH.md have concrete answers
- Production worker file is ready for the geometry bridge (Plan 01-02)
</success_criteria>

<output>
After completion, create `.planning/phases/phase-1/01-01-SUMMARY.md` using the summary template.

CRITICAL: The summary MUST document the answers to all 5 open questions, as Plans 01-02 and 01-03 depend on these findings. Specifically:
- What loading pattern worked (ESM direct URL, importScripts, self-hosted, etc.)
- What is the exact return type of shape.mesh() (number[] vs Float32Array)
- Whether shape.delete() frees memory properly
- Whether XZ plane + Z-axis revolve works for pottery profiles
- Whether replicad_single.js is ESM or not
</output>
