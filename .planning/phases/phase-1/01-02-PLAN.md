---
phase: 01-wasm-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - js/geometryBridge.js
  - js/profileData.js
  - js/workers/memoryTracker.js
autonomous: true

must_haves:
  truths:
    - "Main thread can send a revolve command and receive mesh data back via async/await"
    - "Stale requests are discarded when a new request arrives before the previous completes"
    - "20 consecutive revolve operations do not increase WASM heap beyond the baseline"
    - "Profile data model includes points array, seamLines extension, units, and version"
    - "The test profile (cup shape) produces a valid revolved mesh when sent through the bridge"
  artifacts:
    - path: "js/geometryBridge.js"
      provides: "Promise-based worker communication with cancellation"
      exports: ["init", "revolveProfile", "generateWithCancellation", "destroy"]
      min_lines: 60
    - path: "js/profileData.js"
      provides: "Profile data model with test profile and v2 extension point"
      exports: ["createProfile", "getTestProfile", "validateProfile"]
      min_lines: 40
    - path: "js/workers/memoryTracker.js"
      provides: "withCleanup wrapper for WASM memory safety"
      exports: ["withCleanup"]
      min_lines: 20
  key_links:
    - from: "js/geometryBridge.js"
      to: "js/workers/geometryWorker.js"
      via: "new Worker with postMessage/onmessage"
      pattern: "new Worker.*geometryWorker"
    - from: "js/geometryBridge.js"
      to: "pending Map"
      via: "request ID tracking for Promise resolution"
      pattern: "pending\\.set.*resolve.*reject"
    - from: "js/workers/memoryTracker.js"
      to: "shape.delete()"
      via: "tracked objects cleaned in finally block"
      pattern: "finally.*delete"
---

<objective>
Build the communication layer between main thread and geometry worker, the WASM memory management system, and the profile data model. These three modules are the backbone that every subsequent phase builds on.

Purpose: Establish the Promise-based bridge API so the rest of the app can `await geometryBridge.revolveProfile(points)` without knowing about workers. Implement the withCleanup pattern to guarantee WASM memory safety. Define the profile data model with v2 extension points (requirement INFRA-05).

Output: Three production modules -- geometryBridge.js (main thread), memoryTracker.js (worker), and profileData.js (shared data model).
</objective>

<execution_context>
@/Users/victorhome_1/.claude/get-shit-done/workflows/execute-plan.md
@/Users/victorhome_1/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/phase-1/RESEARCH.md
@.planning/phases/phase-1/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create profile data model with test profile and v2 extension</name>
  <files>js/profileData.js</files>
  <action>
Create `js/profileData.js` as an ES module that defines the canonical profile data model used throughout the entire system. This module has NO dependencies -- it is pure data.

The module must export:

1. `createProfile(points = [])` -- factory function returning:
   ```javascript
   {
     points,        // Array<{ x: number, y: number, type: 'line'|'bezier', cp1?: {x,y}, cp2?: {x,y} }>
     seamLines: [], // v2 extension point (INFRA-05): Array<{ y: number, angle: number }>
     units: 'mm',   // Always mm internally
     version: 1,    // Data format version
   }
   ```

2. `getTestProfile()` -- returns a hardcoded cup shape profile for Phase 1 testing:
   ```javascript
   createProfile([
     { x: 30, y: 0, type: 'line' },       // foot bottom-right (30mm radius)
     { x: 30, y: 3, type: 'line' },        // foot top
     { x: 25, y: 5, type: 'line' },        // foot-to-body transition (tucks in)
     { x: 35, y: 50, type: 'bezier',       // body curve (belly)
       cp1: { x: 22, y: 20 },
       cp2: { x: 30, y: 40 } },
     { x: 40, y: 80, type: 'bezier',       // body to rim
       cp1: { x: 38, y: 55 },
       cp2: { x: 40, y: 70 } },
     { x: 42, y: 85, type: 'line' },       // rim
   ])
   ```

3. `validateProfile(profile)` -- basic validation returning `{ valid: boolean, errors: string[] }`:
   - At least 2 points
   - All points have numeric x >= 0 and numeric y >= 0
   - All points have type 'line' or 'bezier'
   - Bezier points have cp1 and cp2 with numeric x, y
   - No point has x === 0 except the first and last (profile must not cross axis mid-way)
   - version is 1

4. Include JSDoc comments on `createProfile` explaining:
   - x = distance from revolution axis (radius) in mm
   - y = height from bottom in mm
   - Profile represents the OUTER surface of the pot (half cross-section)
   - The closing path (back to axis and down) is added by the geometry worker, NOT stored in the profile
   - seamLines is empty in v1, will hold vertical split definitions for multi-part moulds in v2

Do NOT add any DOM dependencies. This module must work in both main thread and worker contexts.
  </action>
  <verify>
Open a browser console on any page that loads this module and run:
```javascript
import { createProfile, getTestProfile, validateProfile } from './js/profileData.js';
const p = getTestProfile();
console.log(p.points.length); // 6
console.log(p.seamLines);     // []
console.log(p.version);       // 1
console.log(validateProfile(p)); // { valid: true, errors: [] }
```
All assertions pass.
  </verify>
  <done>
Profile data model is defined with createProfile factory, getTestProfile for Phase 1 testing, validateProfile for basic checks, seamLines v2 extension point (INFRA-05), and full JSDoc documentation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create memory tracker and geometry bridge with cancellation</name>
  <files>js/workers/memoryTracker.js, js/geometryBridge.js</files>
  <action>
Create two modules: the WASM memory safety wrapper (worker-side) and the Promise-based communication bridge (main-thread-side).

**File 1: `js/workers/memoryTracker.js`**

Create an ES module that exports `withCleanup(fn)`:

```javascript
/**
 * Track replicad/OCCT objects and ensure cleanup after each operation.
 * Usage: const result = withCleanup((track) => { const shape = track(sketch.revolve()); ... });
 * All tracked objects have .delete() called in the finally block.
 */
export function withCleanup(fn) {
  const tracked = [];
  const track = (obj) => {
    tracked.push(obj);
    return obj;
  };
  try {
    return fn(track);
  } finally {
    for (const obj of tracked) {
      try {
        if (obj && typeof obj.delete === 'function') {
          obj.delete();
        }
      } catch (e) {
        console.warn('[memoryTracker] Failed to delete object:', e);
      }
    }
  }
}
```

Also export a `getHeapSize()` helper that returns the current WASM heap size if available (for memory leak testing):
```javascript
export function getHeapSize() {
  // Access Emscripten HEAP if available
  if (typeof Module !== 'undefined' && Module.HEAP8) {
    return Module.HEAP8.buffer.byteLength;
  }
  return null;
}
```

**Then update `js/workers/geometryWorker.js`** (created in Plan 01-01) to:
- Import `withCleanup` from `./memoryTracker.js`
- Wrap the `revolveProfile` function body in `withCleanup((track) => { ... })`, tracking the revolved shape with `track()`
- Add a `heapSize` command that returns `getHeapSize()` for memory leak testing
- Add a `memoryTest` command that runs N revolve operations and reports heap size after each:
  ```javascript
  case 'memoryTest': {
    const results = [];
    for (let i = 0; i < (params.iterations || 20); i++) {
      revolveProfile(params.profilePoints);
      results.push({ iteration: i + 1, heapSize: getHeapSize() });
    }
    self.postMessage({ id, data: { results } });
    break;
  }
  ```

**File 2: `js/geometryBridge.js`**

Create an ES module that wraps worker communication in Promises:

```javascript
let worker = null;
const pending = new Map();
let nextId = 0;
let currentGenerationId = 0;
```

Export the following functions:

1. `init()` -- Creates the worker, sets up onmessage handler, sends 'init' command, returns a Promise that resolves when WASM is ready:
   ```javascript
   export function init(onProgress) {
     worker = new Worker('./js/workers/geometryWorker.js', { type: 'module' });
     worker.onmessage = (e) => {
       const msg = e.data;
       // Handle progress messages (no ID, broadcast)
       if (msg.type === 'progress') {
         if (onProgress) onProgress(msg.stage, msg.percent);
         return;
       }
       // Handle response messages (have ID)
       const { id, error, data } = msg;
       const resolver = pending.get(id);
       if (!resolver) return;
       pending.delete(id);
       if (error) resolver.reject(new Error(error));
       else resolver.resolve(data);
     };
     return sendCommand('init');
   }
   ```

2. `sendCommand(type, params = {})` -- Internal function (not exported) that creates a request ID, stores resolve/reject in pending Map, posts message to worker.

3. `revolveProfile(profilePoints)` -- Sends revolve command, returns Promise resolving to `{ vertices: Float32Array, normals: Float32Array, triangles: Uint32Array }`.

4. `generateWithCancellation(profilePoints)` -- Implements latest-wins cancellation pattern:
   ```javascript
   export async function generateWithCancellation(profilePoints) {
     const myId = ++currentGenerationId;
     const result = await revolveProfile(profilePoints);
     if (myId !== currentGenerationId) {
       return null; // Stale result, discard
     }
     return result;
   }
   ```

5. `runMemoryTest(profilePoints, iterations = 20)` -- Sends memoryTest command, returns Promise resolving to array of `{ iteration, heapSize }` results. This is for Phase 1 success criteria #3.

6. `destroy()` -- Terminates the worker, clears pending map, rejects all pending promises:
   ```javascript
   export function destroy() {
     if (worker) {
       // Reject all pending promises
       for (const [id, resolver] of pending) {
         resolver.reject(new Error('Worker destroyed'));
       }
       pending.clear();
       worker.terminate();
       worker = null;
     }
   }
   ```

7. `isReady()` -- Returns boolean indicating if the worker has been initialized.

Include JSDoc comments on all exported functions. Do NOT add any DOM dependencies -- this is a pure communication module.

Key design decisions to document in comments:
- Why we use request IDs (multiple concurrent commands)
- Why we use Transferable detection (check if data contains ArrayBuffer properties)
- Why cancellation is generation-counter based, not AbortController (workers can't be interrupted mid-WASM-operation)
  </action>
  <verify>
The files exist and can be validated structurally:
1. `js/workers/memoryTracker.js` exports `withCleanup` and `getHeapSize`
2. `js/geometryBridge.js` exports `init`, `revolveProfile`, `generateWithCancellation`, `runMemoryTest`, `destroy`, `isReady`
3. `js/workers/geometryWorker.js` now uses `withCleanup` in its revolve handler and has `heapSize` and `memoryTest` commands

Functional verification requires a browser test page (created in Plan 01-03).
  </verify>
  <done>
Three modules form the complete communication and memory management layer:
- geometryBridge.js: Promise-based API with init, revolve, cancellation, memory test, and cleanup
- memoryTracker.js: withCleanup wrapper guaranteeing shape.delete() on all tracked OCCT objects
- geometryWorker.js: Updated to use withCleanup and support memory testing commands
Ready for Plan 01-03 to wire these into the end-to-end pipeline.
  </done>
</task>

</tasks>

<verification>
Phase 1 Plan 02 is verified when:
1. profileData.js creates valid profile objects with seamLines extension point
2. getTestProfile() returns the 6-point cup profile
3. validateProfile() accepts good profiles and rejects bad ones
4. geometryBridge.js can create a worker and resolve the init promise (tested in Plan 01-03)
5. memoryTracker.js withCleanup calls .delete() on all tracked objects in finally block
6. geometryWorker.js uses withCleanup in its revolve handler
</verification>

<success_criteria>
- Profile data model includes seamLines array (INFRA-05)
- Geometry bridge provides clean async/await API for worker communication (INFRA-03)
- withCleanup pattern guarantees WASM memory cleanup (INFRA-02)
- Latest-wins cancellation discards stale results (INFRA-03)
- Memory test command enables 20-iteration leak testing (Phase 1 success criteria #3)
- All modules are pure ES modules with no DOM dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/phase-1/01-02-SUMMARY.md` using the summary template.

Document: The API surface of geometryBridge (function signatures), the profile data model structure, and any changes made to geometryWorker.js from Plan 01-01.
</output>
