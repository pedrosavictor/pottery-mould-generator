---
phase: 01-wasm-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - index.html
  - css/style.css
  - js/preview3d.js
  - js/app.js
autonomous: false

must_haves:
  truths:
    - "Opening index.html shows a loading indicator while WASM initializes, and the UI remains responsive during loading"
    - "After WASM loads, the test cup profile is automatically revolved and the resulting 3D mesh renders in the Three.js scene"
    - "User can rotate, zoom, and pan the 3D preview with orbit controls"
    - "Clicking 'Run Memory Test' executes 20 revolves and displays heap sizes showing no continuous growth"
    - "The geometry bridge Promise resolves with vertex/normal/triangle buffers that render correctly"
  artifacts:
    - path: "index.html"
      provides: "Phase 1 test harness with 3D preview and memory test controls"
      min_lines: 40
    - path: "js/preview3d.js"
      provides: "Three.js scene with mesh update from worker data"
      exports: ["initScene", "updateMesh", "clearMesh"]
      min_lines: 60
    - path: "js/app.js"
      provides: "Main thread orchestrator wiring bridge to preview"
      min_lines: 40
    - path: "css/style.css"
      provides: "Basic layout for Phase 1 test harness"
      min_lines: 20
  key_links:
    - from: "js/app.js"
      to: "js/geometryBridge.js"
      via: "import and await init(), then revolveProfile()"
      pattern: "import.*geometryBridge"
    - from: "js/app.js"
      to: "js/preview3d.js"
      via: "passes mesh data from bridge to updateMesh()"
      pattern: "updateMesh.*vertices"
    - from: "js/app.js"
      to: "js/profileData.js"
      via: "imports getTestProfile() for hardcoded cup shape"
      pattern: "import.*getTestProfile"
    - from: "js/preview3d.js"
      to: "Three.js CDN"
      via: "import map resolution for three and OrbitControls"
      pattern: "import.*from.*three"
    - from: "index.html"
      to: "import map"
      via: "script type=importmap defining three and three/addons/"
      pattern: "importmap.*three.*cdn\\.jsdelivr"
---

<objective>
Wire the complete end-to-end pipeline: index.html loads, WASM initializes in worker, test profile is revolved, mesh data transfers to main thread, Three.js renders the 3D solid, and a memory test proves no leaks. This is the final deliverable for Phase 1 -- a working proof that all 5 success criteria are met.

Purpose: Prove the full data flow works (profile points -> worker -> revolve -> mesh -> transfer -> Three.js render) and validate memory management with 20 consecutive operations. This test harness becomes the foundation for all subsequent phases.

Output: A working index.html that loads in the browser, shows the revolved test cup in 3D, and passes the memory leak test.
</objective>

<execution_context>
@/Users/victorhome_1/.claude/get-shit-done/workflows/execute-plan.md
@/Users/victorhome_1/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/phase-1/RESEARCH.md
@.planning/phases/phase-1/01-01-SUMMARY.md
@.planning/phases/phase-1/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Three.js preview module</name>
  <files>js/preview3d.js</files>
  <action>
Create `js/preview3d.js` as an ES module that manages the Three.js 3D scene for rendering mesh data from the geometry worker.

This module imports Three.js and OrbitControls via import map (defined in index.html):
```javascript
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
```

Export the following functions:

1. `initScene(container)` -- Initializes the Three.js scene inside the given DOM element:
   - Create Scene with cream background (`0xf5f0eb`)
   - Create PerspectiveCamera (FOV 45, aspect from container size, near 0.1, far 2000)
   - Position camera at `(0, 80, 250)` looking at origin -- this gives a good view of a cup-sized object (42mm radius, 85mm tall)
   - Create WebGLRenderer with antialias, set pixel ratio to `window.devicePixelRatio`, set size to container dimensions
   - Append renderer.domElement to container
   - Create OrbitControls with damping enabled (`enableDamping = true, dampingFactor = 0.1`)
   - Set controls target to `(0, 42, 0)` -- center of the cup profile height
   - Add lighting:
     - AmbientLight at 0xffffff, intensity 0.5
     - DirectionalLight at 0xffffff, intensity 0.8, position (150, 200, 100)
     - DirectionalLight at 0xffffff, intensity 0.3, position (-100, 100, -50) (fill light)
   - Add a subtle grid helper on the XZ plane (GridHelper with size 200, divisions 20, colors 0xcccccc and 0xdddddd) to give spatial reference
   - Start animation loop (requestAnimationFrame) that calls controls.update() and renderer.render()
   - Add resize handler: listen to window resize, update camera aspect and renderer size

2. `updateMesh(meshData)` -- Receives mesh data from the geometry bridge and renders it:
   - Remove and dispose the previous mesh if it exists (geometry.dispose(), material.dispose(), scene.remove(mesh))
   - Create a new THREE.BufferGeometry
   - Set 'position' attribute from meshData.vertices (Float32Array, itemSize 3)
   - Set 'normal' attribute from meshData.normals (Float32Array, itemSize 3)
   - Set index from meshData.triangles (Uint32Array, itemSize 1)
   - Create MeshStandardMaterial with:
     - color: `0xc2956b` (terra cotta -- Pottery Academy brand color)
     - roughness: 0.7
     - metalness: 0.1
     - side: THREE.DoubleSide (safety -- ensures visibility even if normals are flipped)
     - polygonOffset: true, polygonOffsetFactor: 2.0, polygonOffsetUnits: 1.0
   - Create Mesh from geometry + material, add to scene
   - Store reference to current mesh for later disposal

3. `clearMesh()` -- Removes the current mesh from the scene and disposes resources.

4. `getRenderer()` -- Returns the renderer instance (for testing/debugging).

Handle the case where meshData might have vertices as regular number[] arrays (not typed arrays) -- convert to Float32Array if needed. The spike (Plan 01-01) determined the actual types, but be defensive.

Important: Do NOT create the scene in the module body. The `initScene(container)` call must be explicit so the app controls when rendering starts.
  </action>
  <verify>
The file `js/preview3d.js` exists with:
1. Imports from 'three' and 'three/addons/controls/OrbitControls.js' (import map specifiers)
2. Exported initScene, updateMesh, clearMesh functions
3. Camera positioned for cup-scale objects
4. Proper geometry disposal in updateMesh (prevents Three.js memory leaks)
5. Handles both typed arrays and regular arrays for mesh data
  </verify>
  <done>
Three.js preview module renders BufferGeometry from worker mesh data with orbit controls, lighting, and proper resource disposal. Ready to receive mesh data from the geometry bridge.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create index.html test harness and app.js orchestrator</name>
  <files>index.html, css/style.css, js/app.js</files>
  <action>
Create the Phase 1 test harness that wires everything together: loads WASM, revolves the test profile, renders in Three.js, and runs the memory leak test.

**File 1: `index.html`**

Create the HTML entry point with:

1. Standard HTML5 doctype, viewport meta, title "Pottery Mould Generator - Phase 1 Test"

2. Import map for Three.js (replicad is loaded directly by the worker, not via import map):
   ```html
   <script type="importmap">
   {
     "imports": {
       "three": "https://cdn.jsdelivr.net/npm/three@0.172.0/build/three.module.js",
       "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.172.0/examples/jsm/"
     }
   }
   </script>
   ```

3. Link to `css/style.css`

4. Body structure:
   ```html
   <div id="app">
     <header>
       <h1>Pottery Mould Generator</h1>
       <span id="status">Initializing...</span>
     </header>

     <main>
       <div id="preview-container"></div>

       <aside id="controls">
         <h2>Phase 1 Test Harness</h2>

         <div id="loading-indicator" class="visible">
           <div class="spinner"></div>
           <p id="loading-text">Loading geometry engine...</p>
         </div>

         <div id="test-controls" class="hidden">
           <button id="btn-revolve">Revolve Test Profile</button>
           <button id="btn-memory-test">Run Memory Test (20x)</button>
           <button id="btn-clear">Clear Mesh</button>
         </div>

         <div id="results">
           <h3>Results</h3>
           <pre id="output"></pre>
         </div>

         <div id="memory-results" class="hidden">
           <h3>Memory Test Results</h3>
           <pre id="memory-output"></pre>
         </div>
       </aside>
     </main>
   </div>
   ```

5. Module script tag loading app.js:
   ```html
   <script type="module" src="./js/app.js"></script>
   ```

**File 2: `css/style.css`**

Create basic styling for the test harness:

- CSS custom properties for colors: `--cream: #f5f0eb; --terra-cotta: #c2956b; --sage: #7a8b6f; --dark: #2d2d2d; --border: #ddd;`
- Body: cream background, sans-serif font, no margin
- Header: dark background, cream text, padding
- Main: flexbox layout -- preview-container takes 2/3 width (min-height 500px), aside takes 1/3 width
- preview-container: position relative, aspect-ratio 4/3 or min-height, background slightly darker than cream
- Loading indicator: centered spinner (CSS animation), visible/hidden toggle classes
- Spinner: simple CSS border-based spinner animation
- Buttons: terra cotta background, cream text, padding, border-radius 4px, cursor pointer, hover darken
- Results pre: monospace, overflow auto, max-height 300px, background dark, cream text, padding
- Responsive: at < 768px, stack main vertically (preview on top, controls below)
- `.hidden { display: none; }` and `.visible { display: block; }`

**File 3: `js/app.js`**

Create the main thread orchestrator that:

1. Imports modules:
   ```javascript
   import * as geometryBridge from './geometryBridge.js';
   import * as preview3d from './preview3d.js';
   import { getTestProfile } from './profileData.js';
   ```

2. On DOMContentLoaded, initializes the app:
   ```javascript
   document.addEventListener('DOMContentLoaded', async () => {
     const container = document.getElementById('preview-container');
     const status = document.getElementById('status');
     const output = document.getElementById('output');
     const loadingIndicator = document.getElementById('loading-indicator');
     const loadingText = document.getElementById('loading-text');
     const testControls = document.getElementById('test-controls');

     // Initialize Three.js scene
     preview3d.initScene(container);
     log('Three.js scene initialized');

     // Initialize geometry worker (WASM loading)
     status.textContent = 'Loading WASM...';
     const startTime = performance.now();

     try {
       await geometryBridge.init((stage, percent) => {
         loadingText.textContent = `Loading geometry engine... ${stage} (${percent}%)`;
       });
       const elapsed = Math.round(performance.now() - startTime);
       log(`WASM initialized in ${elapsed}ms`);
       status.textContent = 'Ready';
       loadingIndicator.classList.add('hidden');
       loadingIndicator.classList.remove('visible');
       testControls.classList.remove('hidden');

       // Auto-revolve the test profile on load
       await doRevolve();
     } catch (err) {
       status.textContent = 'ERROR: ' + err.message;
       log('INIT ERROR: ' + err.message);
       log(err.stack || '');
     }
   });
   ```

3. `doRevolve()` function:
   - Gets the test profile via `getTestProfile()`
   - Times the operation with performance.now()
   - Calls `await geometryBridge.revolveProfile(profile.points)`
   - Logs vertex count, normal count, triangle count
   - Calls `preview3d.updateMesh(result)` to render
   - Logs elapsed time
   - Updates status text

4. `doMemoryTest()` function:
   - Gets the test profile
   - Calls `await geometryBridge.runMemoryTest(profile.points, 20)`
   - Displays heap size for each iteration in the memory-results section
   - Calculates: heap after iteration 1, heap after iteration 20, difference
   - Logs whether the test PASSED (heap after #20 approximately equals heap after #2, allowing for small variance) or FAILED (continuous growth)
   - Show the memory-results div

5. Wire up button event listeners:
   - btn-revolve: calls doRevolve()
   - btn-memory-test: calls doMemoryTest()
   - btn-clear: calls preview3d.clearMesh()

6. Helper `log(msg)` function that appends to the #output pre element and also calls console.log.

Key behaviors:
- The UI (loading indicator, buttons, Three.js scene) must remain responsive at all times -- WASM loads in the worker, not main thread
- The test profile auto-revolves immediately after WASM is ready so the user sees the 3D cup shape without clicking anything
- Error handling: catch all async errors and display them in the output area and status bar
  </action>
  <verify>
Serve the project root with an HTTP server:
```bash
cd /workspace/pottery-apps/repos/pottery-mould-generator && npx serve . -l 3000
```

Open http://localhost:3000 in Chrome. Verify:
1. Loading indicator shows while WASM initializes (UI remains responsive -- you can resize the window)
2. After loading, the 3D cup shape appears in the preview automatically
3. Orbit controls work: click-drag to rotate, scroll to zoom, right-click-drag to pan
4. Clicking "Revolve Test Profile" re-generates the mesh
5. Clicking "Run Memory Test (20x)" shows 20 heap sizes -- heap should stabilize after iteration 2
6. Clicking "Clear Mesh" removes the 3D model
7. The output area shows timing information and vertex/triangle counts
8. No errors in the browser console (F12)
  </verify>
  <done>
index.html loads, shows loading state, initializes WASM in worker, auto-revolves test cup profile, renders in Three.js with orbit controls, and memory test shows stable heap across 20 iterations.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete Phase 1 WASM Foundation pipeline: index.html -> app.js -> geometryBridge -> Web Worker (WASM) -> revolve test profile -> mesh data -> Three.js render. Memory leak test harness included.
  </what-built>
  <how-to-verify>
1. Start a local server in the project root: `npx serve . -l 3000` (or `python3 -m http.server 3000`)
2. Open http://localhost:3000 in Chrome
3. Wait for WASM to load (3-15 seconds depending on connection). The loading indicator should be visible and the page should remain responsive (try resizing the window during loading).
4. After loading, a 3D cup shape should appear in the preview. Verify it looks like a revolved cup (rounded body, narrow foot, flared rim).
5. Click and drag on the 3D preview to rotate. Scroll to zoom. Right-click drag to pan.
6. Click "Revolve Test Profile" -- the mesh should regenerate (may flash briefly).
7. Click "Run Memory Test (20x)" -- the memory results section should appear showing 20 heap sizes. The heap size after iteration 20 should be approximately the same as after iteration 2 (small variance is OK, continuous linear growth is NOT OK).
8. Check the browser console (F12) -- there should be no errors related to WASM, module loading, or Three.js.

**Expected results in the output panel:**
- "WASM initialized in Xms" (X is typically 3000-15000)
- "Revolve complete: NNNN vertices, MMMM triangles in Yms"
- Memory test: heap sizes that plateau after the first 1-2 iterations
  </how-to-verify>
  <resume-signal>Type "approved" if the cup renders correctly, orbit controls work, and memory test shows stable heap. Describe any issues if not.</resume-signal>
</task>

</tasks>

<verification>
Phase 1 is complete when ALL 5 success criteria from ROADMAP.md are met:

1. **WASM in Worker (INFRA-01):** OpenCASCADE.js loads in Web Worker, UI responsive during loading
   - Verify: Loading indicator shows, page is interactive during WASM init

2. **Revolution + Render (MOULD-01):** Test profile revolves into 3D solid, renders in Three.js
   - Verify: Cup shape visible in 3D preview after loading

3. **Memory Management (INFRA-02):** 20 revolves without heap growth
   - Verify: "Run Memory Test" shows stable heap sizes

4. **Promise Bridge with Cancellation (INFRA-03):** geometryBridge returns Promises, cancels stale requests
   - Verify: revolveProfile returns mesh data, generateWithCancellation function exists

5. **Profile Data Model v2 Extension (INFRA-05):** seamLines array present
   - Verify: `getTestProfile().seamLines` is an empty array
</verification>

<success_criteria>
- index.html loads and shows the loading indicator while WASM initializes
- The 3D cup shape renders in the Three.js preview after WASM loads
- Orbit controls allow rotation, zoom, and pan of the 3D view
- 20 consecutive revolves show stable WASM heap (no continuous growth)
- The output panel shows timing and mesh statistics
- No errors in the browser console
- All modules are clean ES modules with proper imports
</success_criteria>

<output>
After completion, create `.planning/phases/phase-1/01-03-SUMMARY.md` using the summary template.

Document: The full data flow (profile -> bridge -> worker -> revolve -> mesh -> transfer -> Three.js), timing results (WASM init time, revolve time), memory test results (heap sizes for 20 iterations), and any issues encountered.
</output>
